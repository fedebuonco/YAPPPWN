use crate::constants;
use crate::macaddress::MacAddress64; // Import the type from macaddress.rs
use pcap::{Device, Packet};

pub struct Exploit {
    pub source_mac: MacAddress64,
    pub pppoe_softc: u64,
}

impl Exploit {
    fn update_source_mac(&mut self, value: u64) {
        self.source_mac = MacAddress64::from_u64(value);
        println!("[+] Source MAC: {}", self.source_mac);
    }

    fn build_fake_ifnet(&mut self) {
        // Upper bytes are reserved for session ID
        self.update_source_mac(self.pppoe_softc + 0x07)
    }

    fn handle_padi_packet(&mut self, packet: &Packet) {
        // Extract all miningful stuff from the PADI packet
    }

    pub fn ppp_negotiation(&mut self) {
        // Wait for PADI, throwing away the first.
        let mut cap = Device::lookup().unwrap().unwrap().open().unwrap();
        cap.filter("pppoed", true).unwrap();

        while let Ok(packet) = cap.next_packet() {
            // Check if PADI
            if is_padi_packet(&packet) {
                println!("[+] PADI packet received");
            }
        }
        // Extracting Host Unique Tag and populating the self.pppoe_softc
        // Setting Target and Source MAC Addresses
        // Then finally build the fake interface
    }
}

fn is_padi_packet(packet: &Packet) -> bool {
    let data = packet.data;

    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}
fn extract_host_uniq(packet: &Packet) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    // Extract the host unique tag
    unimplemented!()
}

#[cfg(test)]
mod tests {
    use super::*;
    use pcap::{Capture, Packet};

    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap = Capture::from_file("padi.pcap").expect("Failed to open pcap file");

        let mut found_padi = false;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                found_padi = true;
                println!("Found a PADI packet: {:?}", packet);
            }
        }

        // Assert that at least one PADI packet was found
        assert!(
            found_padi,
            "No PADI packets found in the provided pcap file"
        );
    }
}
