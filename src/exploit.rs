use crate::constants;
use crate::macaddress::MacAddress64; // Import the type from macaddress.rs
use pcap::{Active, Capture, Packet};

pub struct Exploit {
    pub exploit_target_mac: MacAddress64,
    pub pppoe_softc: u64,
    pub cap_device: Capture<Active>,
}

impl Exploit {
    pub fn ppp_negotiation(&mut self) {
        self.cap_device.filter("pppoed", true).unwrap();

        while let Ok(packet) = self.cap_device.next_packet() {
            // Check if PADI
            if !is_padi_packet(&packet) {
                continue;
            }
            println!("{:?}", packet);
            println!("[+] PADI packet received");
            // Extracting Host Unique Tag and populating the self.pppoe_softc
            let host_uniq = extract_host_uniq(&packet).unwrap();
            self.pppoe_softc = u64::from_be_bytes(host_uniq);
            // Extract and update source mac
            let source_mac = extract_source_mac(&packet).unwrap();
            self.exploit_target_mac = source_mac;
            println!("[+] Exploit Target MAC: {}", self.exploit_target_mac);
        }
        // Setting Target and Source MAC Addresses
        // Then finally build the fake interface
    }
}

fn is_padi_packet(packet: &Packet) -> bool {
    let data = packet.data;

    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}
fn extract_host_uniq(packet: &Packet) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let data = packet.data;
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;

        if tag_type == constants::PPPOE_TAG_HOST_UNIQ {
            if offset + tag_len <= data.len() {
                // Extract the Host-Uniq tag value
                let host_uniq = &data[offset..offset + tag_len];
                if tag_len == 8 {
                    // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                    result.copy_from_slice(host_uniq);
                    println!("[+] Extracted Host-Uniq: {:?}", result);
                    break;
                }
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}
fn extract_source_mac(packet: &Packet) -> Result<MacAddress64, Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &packet.data[offset..offset + 6];
    // Convert the byte array to MacAddress64
    // Create a MacAddress64 with the extracted bytes
    let mut mac_address = [0u8; 8];
    mac_address[..6].copy_from_slice(mac_bytes);

    Ok(MacAddress64(mac_address))
}
// fn build_fake_ifnet(pppoe_softc : u64, ):

#[cfg(test)]
mod tests {
    use super::*;
    use pcap::Capture;

    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap = Capture::from_file("padi_2.pcap").expect("Failed to open pcap file");

        let mut found_padi = false;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                found_padi = true;
                println!("Found a PADI packet: {:?}", packet);
            }
        }

        // Assert that at least one PADI packet was found
        assert!(
            found_padi,
            "No PADI packets found in the provided pcap file"
        );
    }

    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap = Capture::from_file("padi_2.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap = Capture::from_file("padi_2.pcap").expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_source_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.0.len(), 8);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac.0[..6], &[0xfa, 0x16, 0x3e, 0x7d, 0xc8, 0x81]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }
}
