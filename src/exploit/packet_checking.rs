use crate::constants;

pub fn is_padi_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}
pub fn is_padr_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADR
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADR
}
pub fn is_ipcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_REQ
}
pub fn is_ipcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_ACK
}
pub fn is_lcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_ACK
}
pub fn is_lcp_conf_reject(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config reject
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_REJECT
}
pub fn is_lcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_REQ
}
pub fn is_icmpv6_router_sol(data: &[u8]) -> bool {
    // Check if packet length is sufficient for IPv6
    if data.len() < 14 + 40 {
        println!("[+] Wrong size: {:?}", data);
        return false;
    }

    // Check Ethernet type field
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_IPV6 {
        println!("[+] Wrong ethertype: {:?}", data);
        return false;
    }

    // Check code field for Router sol
    let ipv6_code = u8::from_be_bytes([data[54]]);
    let result = ipv6_code == constants::IPCPV6_RS;
    println!("[+] Correct router code?: {:?}", result);
    result
}
pub fn is_lcp_echo_request(data: &[u8]) -> bool {
    // Check if packet length is sufficient for LCP echo request
    // 6 + 6 + 2 + 4 = PPP for sure
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for LCP (0xc021)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOESESS {
        return false;
    }

    // Check PPPoE code field
    let pppoe_code = u8::from_be_bytes([data[22]]);
    pppoe_code == constants::PPPOE_CODE_LCP_ECHO_REQ
}
pub fn is_icmpv6_nd_ns(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false;
    }
    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false;
    }

    let ip_header = data[20];
    if ip_header != 0x3a {
        return false;
    }
    let code = data[54];
    code == 135
}
pub fn is_icmpv6_echo_reply(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false; // Minimum length check
    }

    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false; // Only IPv6 packets
    }

    // Check if the next header is ICMPv6
    let ip_header = data[20]; // Assuming IPv6 header starts at index 20
    if ip_header != 0x3a {
        return false; // 0x3a corresponds to ICMPv6
    }

    // Check ICMPv6 type and code for Echo Reply (type: 129, code: 0)
    let icmpv6_type = data[54]; // ICMPv6 type field
    let icmpv6_code = data[55]; // ICMPv6 code field
    icmpv6_type == 129 && icmpv6_code == 0 // Echo Reply type and code
}

#[cfg(test)]
mod tests {

    use super::*;
    use pcap::Capture;

    #[test]
    fn test_is_ipcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_req(packet.data) {
                println!("Found an IPCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_ipcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_ack(packet.data) {
                println!("Found an IPCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_req(packet.data) {
                println!("Found an LCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_ack(packet.data) {
                println!("Found an LCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }
    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                println!("Found a PADI packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that 2 PADI packet were found
        assert_eq!(count, 2);
    }

    #[test]
    fn test_is_padr_packet_from_file() {
        let mut cap =
            Capture::from_file("test_data/padr_packet.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padr_packet(packet.data) {
                println!("Found a PADR packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_router_sol_from_file() {
        let mut cap = Capture::from_file("test_data/icmpv6_router_sol.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_router_sol(packet.data) {
                println!("Found an ICMPv6 Router Solicitation packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_echo_request_from_file() {
        let mut cap = Capture::from_file("test_data/lcp_echo_request.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_echo_request(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_nd_ns() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_nd_ns.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_nd_ns(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }
}
