use crate::constants;

pub fn is_padi_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}
pub fn is_padr_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADR
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADR
}
pub fn is_ipcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_REQ
}
pub fn is_ipcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_ACK
}
pub fn is_lcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_ACK
}
pub fn is_lcp_conf_reject(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config reject
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_REJECT
}
pub fn is_lcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_REQ
}
pub fn is_icmpv6_router_sol(data: &[u8]) -> bool {
    // Check if packet length is sufficient for IPv6
    if data.len() < 14 + 40 {
        return false;
    }

    // Check Ethernet type field
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_IPV6 {
        return false;
    }

    // Check code field for Router sol
    let ipv6_code = u8::from_be_bytes([data[54]]);
    let result = ipv6_code == constants::IPCPV6_RS;
    println!("[+] Correct router code?: {:?}", result);
    result
}
pub fn is_lcp_echo_request(data: &[u8]) -> bool {
    // Check if packet length is sufficient for LCP echo request
    // 6 + 6 + 2 + 4 = PPP for sure
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for LCP (0xc021)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOESESS {
        return false;
    }

    // Check PPPoE code field
    let pppoe_code = u8::from_be_bytes([data[22]]);
    pppoe_code == constants::PPPOE_CODE_LCP_ECHO_REQ
}
pub fn is_icmpv6_nd_ns(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false;
    }
    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false;
    }

    let ip_header = data[20];
    if ip_header != 0x3a {
        return false;
    }
    let code = data[54];
    code == 135
}
pub fn is_icmpv6_echo_reply(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false; // Minimum length check
    }

    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false; // Only IPv6 packets
    }

    // Check if the next header is ICMPv6
    let ip_header = data[20]; // Assuming IPv6 header starts at index 20
    if ip_header != 0x3a {
        return false; // 0x3a corresponds to ICMPv6
    }

    // Check ICMPv6 type and code for Echo Reply (type: 129, code: 0)
    let icmpv6_type = data[54]; // ICMPv6 type field
    let icmpv6_code = data[55]; // ICMPv6 code field
    icmpv6_type == 129 && icmpv6_code == 0 // Echo Reply type and code
}

#[cfg(test)]
mod tests {

    use super::*;
    use pcap::Capture;

    #[test]
    fn test_is_ipcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_req(packet.data) {
                println!("Found an IPCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_ipcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_ack(packet.data) {
                println!("Found an IPCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_req(packet.data) {
                println!("Found an LCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_ack(packet.data) {
                println!("Found an LCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }
    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                println!("Found a PADI packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that 2 PADI packet were found
        assert_eq!(count, 2);
    }

    #[test]
    fn test_is_padr_packet_from_file() {
        let mut cap =
            Capture::from_file("test_data/padr_packet.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padr_packet(packet.data) {
                println!("Found a PADR packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_router_sol_from_file() {
        let mut cap = Capture::from_file("test_data/icmpv6_router_sol.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_router_sol(packet.data) {
                println!("Found an ICMPv6 Router Solicitation packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_echo_request_from_file() {
        let mut cap = Capture::from_file("test_data/lcp_echo_request.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_echo_request(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_nd_ns() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_nd_ns.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_nd_ns(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_reject_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_reject.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_reject(packet.data) {
                println!("Found an LCP CONF REJECT packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF REJECT packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_echo_reply_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap = Capture::from_file("test_data/icmpv6_echo_reply.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_echo_reply(packet.data) {
                println!("Found an ICMPv6 Echo Reply packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of ICMPv6 Echo Reply packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    // Helper function to create a minimal valid packet buffer
    fn create_base_packet(size: usize) -> Vec<u8> {
        vec![0; size]
    }

    #[test]
    fn test_padi_packet_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(14);
        assert!(!is_padi_packet(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(20);
        wrong_type[12] = 0x88;
        wrong_type[13] = 0x64; // Not PPPoE Discovery
        assert!(!is_padi_packet(&wrong_type));

        // Test wrong PPPoE code
        let mut wrong_code = create_base_packet(20);
        wrong_code[12] = 0x88;
        wrong_code[13] = 0x63; // Correct PPPoE Discovery
        wrong_code[15] = 0x0A; // Wrong code (not PADI)
        assert!(!is_padi_packet(&wrong_code));
    }

    #[test]
    fn test_padr_packet_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(14);
        assert!(!is_padr_packet(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(20);
        wrong_type[12] = 0x88;
        wrong_type[13] = 0x64; // Not PPPoE Discovery
        assert!(!is_padr_packet(&wrong_type));

        // Test wrong PPPoE code
        let mut wrong_code = create_base_packet(20);
        wrong_code[12] = 0x88;
        wrong_code[13] = 0x63; // Correct PPPoE Discovery
        wrong_code[15] = 0x09; // Wrong code (PADI instead of PADR)
        assert!(!is_padr_packet(&wrong_code));
    }

    #[test]
    fn test_ipcp_conf_req_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_ipcp_conf_req(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_ipcp_conf_req(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x02; // Wrong code
        assert!(!is_ipcp_conf_req(&wrong_code));
    }

    #[test]
    fn test_ipcp_conf_ack_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_ipcp_conf_ack(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_ipcp_conf_ack(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x01; // Wrong code
        assert!(!is_ipcp_conf_ack(&wrong_code));
    }

    #[test]
    fn test_lcp_conf_req_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_conf_req(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_lcp_conf_req(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x02; // Wrong code
        assert!(!is_lcp_conf_req(&wrong_code));
    }

    #[test]
    fn test_lcp_conf_ack_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_conf_ack(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_lcp_conf_ack(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x01; // Wrong code
        assert!(!is_lcp_conf_ack(&wrong_code));
    }

    #[test]
    fn test_lcp_conf_reject_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_conf_reject(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_lcp_conf_reject(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x01; // Wrong code
        assert!(!is_lcp_conf_reject(&wrong_code));
    }

    #[test]
    fn test_icmpv6_router_sol_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(53);
        assert!(!is_icmpv6_router_sol(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(55);
        wrong_type[12] = 0x86;
        wrong_type[13] = 0xdc; // Not IPv6
        assert!(!is_icmpv6_router_sol(&wrong_type));

        // Test wrong ICMPv6 code
        let mut wrong_code = create_base_packet(55);
        wrong_code[12] = 0x86;
        wrong_code[13] = 0xdd; // Correct IPv6
        wrong_code[54] = 0x87; // Wrong ICMPv6 code
        assert!(!is_icmpv6_router_sol(&wrong_code));
    }

    #[test]
    fn test_lcp_echo_request_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_echo_request(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[12] = 0x88;
        wrong_type[13] = 0x63; // Wrong type
        assert!(!is_lcp_echo_request(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[12] = 0x88;
        wrong_code[13] = 0x64; // Correct type
        wrong_code[22] = 0x0A; // Wrong code
        assert!(!is_lcp_echo_request(&wrong_code));
    }

    #[test]
    fn test_icmpv6_nd_ns_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_icmpv6_nd_ns(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(55);
        wrong_type[12] = 0x86;
        wrong_type[13] = 0xdc; // Not IPv6
        assert!(!is_icmpv6_nd_ns(&wrong_type));

        // Test wrong IP header
        let mut wrong_ip = create_base_packet(55);
        wrong_ip[12] = 0x86;
        wrong_ip[13] = 0xdd; // Correct IPv6
        wrong_ip[20] = 0x3b; // Wrong next header
        assert!(!is_icmpv6_nd_ns(&wrong_ip));

        // Test wrong ICMPv6 code
        let mut wrong_code = create_base_packet(55);
        wrong_code[12] = 0x86;
        wrong_code[13] = 0xdd; // Correct IPv6
        wrong_code[20] = 0x3a; // Correct next header
        wrong_code[54] = 136; // Wrong code (not 135)
        assert!(!is_icmpv6_nd_ns(&wrong_code));
    }

    #[test]
    fn test_icmpv6_echo_reply_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_icmpv6_echo_reply(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(56);
        wrong_type[12] = 0x86;
        wrong_type[13] = 0xdc; // Not IPv6
        assert!(!is_icmpv6_echo_reply(&wrong_type));

        // Test wrong IP header
        let mut wrong_ip = create_base_packet(56);
        wrong_ip[12] = 0x86;
        wrong_ip[13] = 0xdd; // Correct IPv6
        wrong_ip[20] = 0x3b; // Wrong next header
        assert!(!is_icmpv6_echo_reply(&wrong_ip));

        // Test wrong ICMPv6 type
        let mut wrong_type_code = create_base_packet(56);
        wrong_type_code[12] = 0x86;
        wrong_type_code[13] = 0xdd; // Correct IPv6
        wrong_type_code[20] = 0x3a; // Correct next header
        wrong_type_code[54] = 128; // Wrong type (not 129)
        wrong_type_code[55] = 0; // Correct code
        assert!(!is_icmpv6_echo_reply(&wrong_type_code));

        // Test wrong ICMPv6 code
        let mut wrong_code = create_base_packet(56);
        wrong_code[12] = 0x86;
        wrong_code[13] = 0xdd; // Correct IPv6
        wrong_code[20] = 0x3a; // Correct next header
        wrong_code[54] = 129; // Correct type
        wrong_code[55] = 1; // Wrong code (not 0)
        assert!(!is_icmpv6_echo_reply(&wrong_code));
    }
}
