use super::packet_checking::is_lcp_echo_request;
use super::packet_creation::create_lcp_echo_reply;
use super::utils::create_ethernet_channel;
use crate::constants;
use pnet::datalink::{DataLinkReceiver, DataLinkSender, NetworkInterface};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread::{self, JoinHandle};

pub struct LcpEchoHandler<'a> {
    interface: &'a NetworkInterface,
    running: Arc<AtomicBool>,
    thread_handle: Option<JoinHandle<()>>,
}

impl<'a> LcpEchoHandler<'a> {
    pub fn new(interface: &'a NetworkInterface) -> Self {
        Self {
            interface,
            running: Arc::new(AtomicBool::new(false)),
            thread_handle: None,
        }
    }

    pub fn start(&mut self) {
        println!("[*] Starting LCP Echo Handler...");
        let running = Arc::new(AtomicBool::new(true));
        self.running = Arc::clone(&running);
        let interface = self.interface.clone();

        let (mut tx, mut rx) = create_ethernet_channel(&interface).unwrap();

        // Pass channel to the thread and run
        let running_in_thread = Arc::clone(&running);
        let handle = thread::spawn(move || {
            while running_in_thread.load(Ordering::Relaxed) {
                LcpEchoHandler::echo_handler(tx.as_mut(), rx.as_mut());
            }
            println!("Thread has stopped.");
        });

        self.thread_handle = Some(handle);
    }

    pub fn stop(&mut self) {
        // Stop the thread
        self.running.store(false, Ordering::Relaxed);
        if let Some(handle) = self.thread_handle.take() {
            handle.join().unwrap();
        }
    }

    fn echo_handler(tx: &mut dyn DataLinkSender, rx: &mut dyn DataLinkReceiver) {
        println!("[*] Starting loop for LCP Echo Request...");
        loop {
            match rx.next() {
                Ok(packet) => {
                    // If it is an LCP echo request, send a reply
                    if is_lcp_echo_request(packet) {
                        println!("[*] Found LCP Echo Request...");
                        Self::send_echo_reply(tx, packet);
                    }
                }
                Err(e) => {
                    panic!("An error occurred while reading a packet: {}", e);
                }
            }
        }
    }

    fn send_echo_reply(tx: &mut dyn DataLinkSender, request: &[u8]) {
        let source_mac: [u8; 6] = request[0..6]
            .try_into()
            .expect("Slice with incorrect length");

        let target_mac: [u8; 6] = request[6..12]
            .try_into()
            .expect("Slice with incorrect length");

        let identifier = request[23];

        let magic_number: [u8; 4] = request[26..30].try_into().expect("errpor");

        // Build the LCP reply
        let lcp_reply = create_lcp_echo_reply(
            source_mac,
            target_mac,
            constants::PPPOE_SESSION_ID.to_be_bytes(),
            identifier,
            magic_number,
        );
        // Use it to send the response
        let _result = tx
            .send_to(&lcp_reply, None)
            .expect("[-] Failed to send Echo Reply");
    }
}

